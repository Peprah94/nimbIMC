control = pfControl)
}
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "bootstrap"){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}
message("Compiling the particle filter")
#compiling the model
compiledParticleFilter <- nimble::compileNimble(model,  particleFilter)
#Log likelihood of last run and the Effective sample sizes
message("Running the particle filter")
logLik <-   compiledParticleFilter$particleFilter$run(m = nParFiltRun)
ESS <-   compiledParticleFilter$particleFilter$returnESS()
logLik
ESS
message(paste("Fitting reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
example1ReducedModel <- spartaNimWeights(model = newModelReduced, latent = "x", mcmc = TRUE,
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
)
#save results
save(example1ReducedModel, file= paste0("example1ReducedIn",iNodePrev[iNodetag],"A",aVarstag,".RData"))
model = stateSpaceModel
latent = "x"
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
weights = example1ReducedModel$weights
unweightedLatentSamples = example1ReducedModel$mvWS
weightedLatentSamples = example1ReducedModel$mvEWS
loglike = example1ReducedModel$logLike
postReducedMCMC = example1ReducedModel$mcmcSamplesAndSummary
mvSamplesEst =  example1ReducedModel$mvSamplesEst
mvSamplesEst
pfControl = list(saveAll = TRUE,
#lookahead = "mean",
smoothing = FALSE,
mcmc = TRUE,
M = nyears - iNodePrev[iNodetag],
iNodePrev = iNodePrev[iNodetag])
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
iNodePrev = pfControl[["iNodePrev"]]
M = pfControl[["M"]]
#iNodePrev = updatePFControl[["iNodePrev"]]
#M = updatePFControl[["M"]]
if(is.null(nParFiltRun)) nParFiltRun =  n.iter - n.burnin
inits <- as.list(target)
names(inits) <- target
for(i in 1:length(target)){
expandTarget <- model$expandNodeNames(target[i])
inits[[target[i]]] <- c(postReducedMCMC$summary$all.chains[expandTarget, 'Mean'])
}
model$setInits(inits)
#create new model for weights
estimationModel <- model$newModel(replicate = TRUE)
message("Building particle filter for model")
if(is.null(pfType)){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
}
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "bootstrap"){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}
message("Compiling the particle filter")
#compiling the model
compiledParticleFilter <- nimble::compileNimble(model,  particleFilter)
#save results
save(example1ReducedModel, file= paste0("example1ReducedIn",iNodePrev[iNodetag],"A",aVarstag,".RData"))
logLik <-   compiledParticleFilter$particleFilter$run(m = nParFiltRun)
logLik
ESS <-   compiledParticleFilter$particleFilter$returnESS()
ESS
devtools::load_all(".")
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
iNodePrev = pfControl[["iNodePrev"]]
M = pfControl[["M"]]
#iNodePrev = updatePFControl[["iNodePrev"]]
#M = updatePFControl[["M"]]
if(is.null(nParFiltRun)) nParFiltRun =  n.iter - n.burnin
inits <- as.list(target)
names(inits) <- target
for(i in 1:length(target)){
expandTarget <- model$expandNodeNames(target[i])
inits[[target[i]]] <- c(postReducedMCMC$summary$all.chains[expandTarget, 'Mean'])
}
model$setInits(inits)
#create new model for weights
estimationModel <- model$newModel(replicate = TRUE)
message("Building particle filter for model")
if(is.null(pfType)){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
}
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "bootstrap"){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}
message("Compiling the particle filter")
#compiling the model
compiledParticleFilter <- nimble::compileNimble(model,  particleFilter)
devtools::load_all(".")
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
iNodePrev = pfControl[["iNodePrev"]]
M = pfControl[["M"]]
#iNodePrev = updatePFControl[["iNodePrev"]]
#M = updatePFControl[["M"]]
if(is.null(nParFiltRun)) nParFiltRun =  n.iter - n.burnin
inits <- as.list(target)
names(inits) <- target
for(i in 1:length(target)){
expandTarget <- model$expandNodeNames(target[i])
inits[[target[i]]] <- c(postReducedMCMC$summary$all.chains[expandTarget, 'Mean'])
}
model$setInits(inits)
#create new model for weights
estimationModel <- model$newModel(replicate = TRUE)
message("Building particle filter for model")
if(is.null(pfType)){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
}
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "bootstrap"){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
target = target,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
mvSamplesEst = mvSamplesEst,
control = pfControl)
}
message("Compiling the particle filter")
#compiling the model
compiledParticleFilter <- nimble::compileNimble(model,  particleFilter)
#Log likelihood of last run and the Effective sample sizes
message("Running the particle filter")
logLik <-   compiledParticleFilter$particleFilter$run(m = nParFiltRun)
ESS <-   compiledParticleFilter$particleFilter$returnESS()
ESS
#newModel <- model$newModel(replicate = TRUE)
modelMCMCconf <- nimble::configureMCMC(model, nodes = NULL)
if(is.null(pfType)){
pfTypeUpdate = 'bootstrapUpdate'
}else{
if(pfType == "bootstrap"){
pfTypeUpdate = 'bootstrapUpdate'
}else{
if(pfType == "auxiliary") {
pfTypeUpdate = 'auxiliaryUpdate'
}
modelMCMCconf$addSampler(target = target,
type = 'RW_PF_blockUpdate',
control = list(latents = latent,
target = target,
pfControl = list(saveAll = TRUE, M = M, iNodePrev = iNodePrev),
pfNparticles = nParFiltRun,
pfType = pfTypeUpdate,
weights = weights,
unweightedSamples= unweightedLatentSamples,
weightedSamples = weightedLatentSamples,
mvSamplesEst = mvSamplesEst,
logLikeVals = loglike))
modelMCMCconf$addMonitors(additionalPars)
message("Building and compiling the PF MCMC")
## build and compile pMCMC sampler
modelMCMC <- nimble::buildMCMC(modelMCMCconf)
compiledList <- nimble::compileNimble(model,
modelMCMC,
resetFunctions = TRUE)
timeStart2 <- Sys.time()
message("Running the PF MCMC")
#run MCMC
mcmc.out <- nimble::runMCMC(compiledList$modelMCMC,
niter = n.iter,
nchains = n.chains,
nburnin = n.burnin,
#inits = initsList,
thin = n.thin,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
mcmc.out$summary$all.chains
devtools::load_all(".")
mcmc.out$summary$chain1
## load the nimble library and set seed
library('nimble')
library(nimbleSMC)
library(myphdthesis)
set.seed(1)
# Setting up MCMC configuration values and variation of parameters
nIterations = 5000
nBurnin = 100
nChains = 2
nThin = 1
nyears = 50
aVars <- c(0.1, 0.8) # changing the intercept
#High and small values of a
iNodePrev <- c(49, 45, 20) # The number of years for reduced model
aVarstag = 2
iNodetag = 2
sim2 <- function(a, b, c, t, mu0){
x <- y <- numeric(t)
x[1] <- rnorm(1, mu0, 1 )
y[1] <- rnorm(1, x[1], 1)
for(k in 2:t){
x[k] <- rnorm(1, a*x[k -1] + b, 1)
y[k] <- rnorm(1, x[k-1]*c, 1)# + (sigOE * (sqrt(df -2)/df) * rt(1, df))
}
return(list(x=x, y=y))
}
message("simulating data for a = ", aVars[aVarstag])
simData <- sim2(a = aVars[aVarstag],
b = 1,
c = 1.5,
t = nyears,
mu0 = 0.2)
#save data
save(simData, file = paste0("example1SimData",aVarstag,".RData"))
stateSpaceCode <- nimbleCode({
x[1] ~ dnorm(mu0, 1)
y[1] ~ dnorm(x[1], 1)
for(i in 2:t){
x[i] ~ dnorm(x[i-1] * a + b, 1)
y[i] ~ dnorm(x[i] * c, 1)
}
a ~ dunif(0, 1)
b ~ dnorm(0, 1)
c ~ dnorm(1,1)
mu0 ~ dnorm(0, 1)
})
#
# ## define data, constants, and initial values
data <- list(
#   #y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
y = simData$y
)
constants <- list(
t = nyears
)
inits <- list(
a = 0.1,
b = 0,
mu0= 0.2,
c = 1
)
#
# ## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
check = FALSE)
message("Running baseline model (particle MCMC from nimbleSMC) for a = ", aVars[aVarstag])
#Define a new model
newModel <- stateSpaceModel$newModel(replicate = TRUE)
# Function to run the baseline model
baselineModel <- myphdthesis::baselineSpartaEstimation(model = newModel, latent = "x",
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin))
#Save results
save(baselineModel, file = paste0("example1BaselineSMC",aVarstag,".RData"))
message(paste("Running reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
message(paste("Reduced model configuration for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
data <- list(
#y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
y = simData$y[-c((iNodePrev[iNodetag]+1):50)]
)
constants <- list(
t = iNodePrev[iNodetag]
)
newModelReduced <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
check = FALSE)
message(paste("Fitting reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
example1ReducedModel <- spartaNimWeights(model = newModelReduced, latent = "x", mcmc = TRUE,
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
)
library(myphdthesis)
devtools::load_all(".")
library(myphdthesis)
devtools::load_all(".")
library(myphdthesis)
source("~/.active-rstudio-document", echo=TRUE)
