y = simData$y
)
constants <- list(
nyear = n.years,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
occStateSpaceModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
data <- list(
y = simData$y
)
constants <- list(
nyear = n.years,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
#setParameters
n.years = 25
nReducedYears = 20
n.sites = 30
n.visits = 6
data <- list(
y = simData$y
)
constants <- list(
nyear = n.years,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
occStateSpaceModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
data <- list(
y = simData$y[,,1:nReducedYears]
)
constants <- list(
nyear = nReducedYears,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
newModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
#newModel <- occStateSpaceModel$newModel(replicate = TRUE)
#newModel$y[,,15:20] <- NA
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfControl = list(saveAll = TRUE,
lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = c('mean.p', 'a'),
additionalPars = "psi.fs",
n.iter = 10000,
n.chains = 3,
n.burnin = 5000)
)
model = newModel
pfControl = list(saveAll = TRUE,
lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2)
latent = "z"
MCMCconfiguration = list(target = c('mean.p', 'a'),
additionalPars = "psi.fs",
n.iter = 10000,
n.chains = 3,
n.burnin = 5000)
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
if(is.null(nParFiltRun)) nParFiltRun = 10000
nParFiltRun = 10000
message("Building particle filter for model")
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "auxiliary"){
particleFilter <- myphdthesis::buildAuxiliaryFilterNew(model,
latent,
control = pfControl)
}
if(pfType == "bootstrap"){
particleFilter <- nimbleSMC::buildBootstrapFilter(model,
latent,
control = pfControl)
}
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterNew(model,
latent,
control = pfControl)
}
particleFilter <- myphdthesis::buildAuxiliaryFilterNew(model,
latent,
control = pfControl)
particleFilter <- myphdthesis::buildAuxiliaryFilter(model,
latent,
control = pfControl)
buildAuxiliaryFilter(model,
latent,
control = pfControl)
particleFilter <- nimbleSMC::buildAuxiliaryFilter(model,
latent,
control = pfControl)
library(nimble)
library(nimbleSMC)
library('nimble')
library(nimbleSMC)
library(myphdthesis)
set.seed(1)
source("spartaUpdatingFunctions.R")
simSpartaData <- function(nsites, nvisits, nyears, intercept.p, init.a, AR1 = FALSE){
set.seed(24)
yearSim <- seq(1, nyears,1)
Site <- seq(1, nsites,1)
#p <- plogis(intercept.p)
if(AR1 == TRUE){
a <- numeric(nyears)
a[1] <- init.a
for(year.tag in 2:nyears){
a[year.tag] <- rnorm(1, a[year.tag -1], sd = 1)
}
}else{
a <- numeric(nyears)
#a[1] <- init.a
#for(year.tag in 2:nyears){
for(year.tag in 1:nyears){
a[year.tag] <- init.a
}
z <- matrix(NA, nrow = nsites, ncol = nyears)
for(site.tag in 1:nsites){
for(year.tag in 1:nyears){
z[site.tag, year.tag] <- rbinom(1, 1, plogis(a[year.tag]))
}
p <- psi.fs <- numeric(nvisits)
y <- array(NA, dim = c(nsites, nvisits, nyears))
for(visit.tag in 1:nvisits) {
p[visit.tag] <-  plogis(intercept.p)
}
#Py[visit.tag] <- z[Site[visit.tag], yearSim[visit.tag]]*p[visit.tag]
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits) {
for(year.tag in 1:nyears){
y[site.tag, visit.tag, year.tag] <- rbinom(1,1, z[Site[site.tag], yearSim[year.tag]]*p[visit.tag])
}
#prop of occupied sutes
for (t in 1:nyears) {
psi.fs[t] <- sum(z[1:nsites, t])/nsites
}
return(list(z = z, y = y, psi.fs = psi.fs, a = a, Site = Site, Year = yearSim))
}
#setParameters
n.years = 25
nReducedYears = 20
n.sites = 30
n.visits = 6
simData <- simSpartaData(nsites = n.sites, nvisits = n.visits, nyears = n.years, intercept.p = 2, init.a = -1, AR1 = FALSE)
save(simData, file="simSpartaData.RData")
getwd()
occStateModel <- nimbleCode({
# JAGS code for SPARTA model plus random walk prior
# State model
for (i in 1:nsite){
for (t in 1:nyear){
z[i,t] ~ dbern(muZ[i,t])
#logit(muZ[i,t])<- a[t]
}
for (i in 1:nsite){
for (t in 1:nyear){
logit(muZ[i,t])<- a
}
for(j in 1:nvisit){
logit(p[j]) <-  intercept.p
}
### Observation Model
for(i in 1:nsite){
for(j in 1:nvisit){
for(k in 1:nyear){
y[i,j, k] ~ dbern(z[Site[i],Year[k]]*p[j])
}
# State model priors
#random walk prior
#a[1] ~ dnorm(0, tau = 0.001)
#for(t in 1:nyear){
# a[t] <- int.a
#}
# State model priors
a ~ dnorm(0, tau = 0.01)
#tau.a <- 1/(sd.a * sd.a)
# sd.prior ~ dt(0, 1, 1)# I(0,1000)
# sd.a ~ dconstraint(sd.prior >0 )
# Observation model priors
mean.p ~ dnorm(0,1)
logit(intercept.p) <- mean.p
# Derived parameters - prop of occuppied sites
for (t in 1:nyear) {
psi.fs[t] <- sum(z[1:nsite, t])/nsite
}
)
data <- list(
y = simData$y
)
constants <- list(
nyear = n.years,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
occStateSpaceModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
data <- list(
y = simData$y[,,1:nReducedYears]
)
constants <- list(
nyear = nReducedYears,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
newModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
#newModel <- occStateSpaceModel$newModel(replicate = TRUE)
#newModel$y[,,15:20] <- NA
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfControl = list(saveAll = TRUE,
lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = c('mean.p', 'a'),
additionalPars = "psi.fs",
n.iter = 10000,
n.chains = 3,
n.burnin = 5000)
)
load("case2SimData.RData")
## define the model
message("Running baseline model")
stateSpaceCode <- nimbleCode({
a ~ dnorm(0, sd = 100)
b ~ dnorm(0, sd = 100)
sigPN ~ dunif(1e-04, 100)
sigOE ~ dunif(1e-04, 100)
# x[1] ~ dnorm(b/(1 - a), sd = sigPN/sqrt((1-a*a)))
x[1] ~ dnorm(0, sd = sigPN)
y[1] ~ dnorm(x[1], sd = sigOE)
for (i in 2:t) {
x[i] ~ dnorm(a * x[i - 1] + b, sd = sigPN)
y[i] ~ dnorm(x[i], sd = sigOE)
}
})
## define data, constants, and initial values
data <- list(
#y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
y = simData$y
)
constants <- list(
t = 50
)
inits <- list(
a = 0,
b = .5,
sigPN = .1,
sigOE = .05
)
data <- list(
#y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
y = simData$y[-c(46:50)]
)
constants <- list(
t = 45
)
newModelReduced <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
check = FALSE)
reducedCase2 <- spartaNimWeights(model = newModelReduced, latent = "x",
MCMCconfiguration = list(target = c('a', 'b', 'sigPN', 'sigOE'),
additionalPars = "x",
n.iter = 10000,
n.chains = 3,
n.burnin = 5000)
)
library(nimble)
library(nimbleSMC)
library('nimble')
library(nimbleSMC)
library(myphdthesis)
source("/Volumes/kwakupa/particleFilters/spartaUpdatingFunctions.R")
set.seed(1)
source("spartaUpdatingFunctions.R")
simSpartaData <- function(nsites, nvisits, nyears, intercept.p, init.a, AR1 = FALSE){
set.seed(24)
yearSim <- seq(1, nyears,1)
Site <- seq(1, nsites,1)
#p <- plogis(intercept.p)
if(AR1 == TRUE){
a <- numeric(nyears)
a[1] <- init.a
for(year.tag in 2:nyears){
a[year.tag] <- rnorm(1, a[year.tag -1], sd = 1)
}
}else{
a <- numeric(nyears)
#a[1] <- init.a
#for(year.tag in 2:nyears){
for(year.tag in 1:nyears){
a[year.tag] <- init.a
}
z <- matrix(NA, nrow = nsites, ncol = nyears)
for(site.tag in 1:nsites){
for(year.tag in 1:nyears){
z[site.tag, year.tag] <- rbinom(1, 1, plogis(a[year.tag]))
}
p <- psi.fs <- numeric(nvisits)
y <- array(NA, dim = c(nsites, nvisits, nyears))
for(visit.tag in 1:nvisits) {
p[visit.tag] <-  plogis(intercept.p)
}
#Py[visit.tag] <- z[Site[visit.tag], yearSim[visit.tag]]*p[visit.tag]
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits) {
for(year.tag in 1:nyears){
y[site.tag, visit.tag, year.tag] <- rbinom(1,1, z[Site[site.tag], yearSim[year.tag]]*p[visit.tag])
}
#prop of occupied sutes
for (t in 1:nyears) {
psi.fs[t] <- sum(z[1:nsites, t])/nsites
}
return(list(z = z, y = y, psi.fs = psi.fs, a = a, Site = Site, Year = yearSim))
}
#setParameters
n.years = 25
nReducedYears = 20
n.sites = 30
n.visits = 6
simData <- simSpartaData(nsites = n.sites, nvisits = n.visits, nyears = n.years, intercept.p = 2, init.a = -1, AR1 = FALSE)
occStateModel <- nimbleCode({
# JAGS code for SPARTA model plus random walk prior
# State model
for (i in 1:nsite){
for (t in 1:nyear){
z[i,t] ~ dbern(muZ[i,t])
#logit(muZ[i,t])<- a[t]
}
for (i in 1:nsite){
for (t in 1:nyear){
logit(muZ[i,t])<- a
}
for(j in 1:nvisit){
logit(p[j]) <-  intercept.p
}
### Observation Model
for(i in 1:nsite){
for(j in 1:nvisit){
for(k in 1:nyear){
y[i,j, k] ~ dbern(z[Site[i],Year[k]]*p[j])
}
# State model priors
#random walk prior
#a[1] ~ dnorm(0, tau = 0.001)
#for(t in 1:nyear){
# a[t] <- int.a
#}
# State model priors
a ~ dnorm(0, tau = 0.01)
#tau.a <- 1/(sd.a * sd.a)
# sd.prior ~ dt(0, 1, 1)# I(0,1000)
# sd.a ~ dconstraint(sd.prior >0 )
# Observation model priors
mean.p ~ dnorm(0,1)
logit(intercept.p) <- mean.p
# Derived parameters - prop of occuppied sites
for (t in 1:nyear) {
psi.fs[t] <- sum(z[1:nsite, t])/nsite
}
)
data <- list(
y = simData$y
)
constants <- list(
nyear = n.years,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z
)
simData$z
occStateSpaceModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
data <- list(
y = simData$y[,,1:nReducedYears]
)
constants <- list(
nyear = nReducedYears,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$zsimData$y[,1:nReducedYears]
)
data <- list(
y = simData$y[,,1:nReducedYears]
)
constants <- list(
nyear = nReducedYears,
nvisit = n.visits,
nsite = n.sites,
Site = simData$Site,
Year = simData$Year
)
inits <- list(
mean.p = 0,
int.a = 1,
# sd.prior = .5,
a = 0,
z = simData$z[,1:nReducedYears]
)
newModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
#newModel <- occStateSpaceModel$newModel(replicate = TRUE)
#newModel$y[,,15:20] <- NA
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfControl = list(saveAll = TRUE,
lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = c('mean.p', 'a'),
additionalPars = "psi.fs",
n.iter = 10000,
n.chains = 3,
n.burnin = 5000)
)
simData$z[,1:nReducedYears]
