fixedVals,
family){
res <- inlabruModelFit(x=x,
y=y,
beta = betaMatrix[i, ],
extraVars = extraVarsMatrix[i, ],
fixedVals = fixedVals,
family=family)
return(res)
}
m <- nrow(betaMatrix)
allResults <- parallel::mclapply(1:m,
runFnx,
x,
y,
betaMatrix,
extraVarsMatrix,
fixedVals,
family,
mc.cores = nCores)
ret <- do.call("rbind", allResults)
return(ret)
}
# Set up the R function for use in INLA
nimbleINLA <- nimble::nimbleRcall(
prototype = function(
x=double(2), #x is a matrix
y=integer(2), #y is a matrix
beta=double(2), # beta is a matrix
extraVarsMatrix = double(2),
fixedVals = character(1, default = c("intercept", "sigma","theta1")),
#interInModel = double(0, default = 1),
family = character(0, default = "binomial"),
nCores = integer(0, default = 1)
) {},
returnType = double(2), # outcome is a vector
Rfun = 'fit.inlaPar'
)
zst <- apply(dataSimulated$y[indxOfSitesObs,], 1, function(t){
r <-sum(t)
rt <- as.numeric(r>0)
#rt <- ifelse(rt==0, NA, rt)
return(rt)
})
#text if it works
inlabruModelFit(x, y = x, beta = c(2, -2), extraVars = zst, fixedVals = c("intercept", "sigma","theta1"), family = "binomial")
y = x
beta = c(2, -2)
extraVars = zst
dataSimulated$z
dataSimulated$trueNocc
dataSimulated$obsNocc
dataSimulated$y
dataSimulated$yobs
indxOfSitesObs
dataSimulated$y[indxOfSitesObs,]
extraVars = zst
fixedVals = c("intercept", "sigma","theta1")
family = "binomial"
# Simulate data
coordsData <- x%>%
as.data.frame()
#convert y to vector
y <- c(extraVars)
#p <- plogis(beta[1] + beta[2]* x[,5] + beta[3]* x[,6])
#p = c(beta)
#coordsData <- cbind(coordsData, p)
colnames(coordsData) <- c("Longitude","Latitude","elevationS","i_year" , "forest", "wind" )
coordsDataNew <- sf::st_as_sf(coordsData,
coords = c("Longitude",
"Latitude"))
max.edge = diff(range(sf::st_coordinates(coordsDataNew)[,1]))/(3*5)
mesh1 = inla.mesh.2d(loc = st_coordinates(coordsDataNew),
max.edge = c(max.edge-10, max.edge+10))
plot(mesh1)
#SPDE with exponential correlation function
spde = inla.spde2.matern(mesh = mesh1,
alpha = 1.5)
elev.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (beta[1]*coordsDataNew$elevationS)))
elev.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (coordsDataNew$elevationS)))
plot(elev.spix)
st_coordinates(coordsDataNew)
coordsDataNew$elevationS
dataSimulated$elevationS
dataSimulated
dataForModel <- data.frame(Longitude = dataSimulated$xcoord,
Latitude = dataSimulated$ycoord,
elevationS = dataSimulated$elevationS,
obsY = dataSimulated$y[,1],
i_year = as.integer(factor(rep(1, each = length(dataSimulated$xcoord))) ))%>%
as.matrix()
dataForModel
dataSimulated$y
dataSimulated$yobs[,1]
sum(!is.na(dataSimulated$yobs[,1]))
x <- cbind(as.matrix(dataForModel),
rep(standardize(c(dataSimulated$forest)), 1),
c(dataSimulated$wind[,1]))%>%
as.matrix()
x[ ,1] <- x[ ,1]/1000
x[ ,2] <- x[ ,2]/1000
x <- cbind(x, x[ ,3]^2)#coordsData$elevationS^2
x
dataSimulated$yobs[,1]
dataForModel <- data.frame(Longitude = dataSimulated$xcoord,
Latitude = dataSimulated$ycoord,
elevationS = dataSimulated$elevationS,
obsY = dataSimulated$yobs[,1],
i_year = as.integer(factor(rep(1, each = length(dataSimulated$xcoord))) ))%>%
as.matrix()
x <- cbind(as.matrix(dataForModel),
rep(standardize(c(dataSimulated$forest)), 1),
c(dataSimulated$wind[,1]))%>%
as.matrix()
x[ ,1] <- x[ ,1]/1000
x[ ,2] <- x[ ,2]/1000
x <- cbind(x, x[ ,3]^2)#coordsData$elevationS^2
x
# Simulate data
coordsData <- x%>%
as.data.frame()
coordsData
#convert y to vector
y <- c(extraVars)
#p <- plogis(beta[1] + beta[2]* x[,5] + beta[3]* x[,6])
#p = c(beta)
#coordsData <- cbind(coordsData, p)
colnames(coordsData) <- c("Longitude","Latitude","elevationS", "obsY","i_year" , "forest", "wind" )
coordsDataNew <- sf::st_as_sf(coordsData,
coords = c("Longitude",
"Latitude"))
max.edge = diff(range(sf::st_coordinates(coordsDataNew)[,1]))/(3*5)
mesh1 = inla.mesh.2d(loc = st_coordinates(coordsDataNew),
max.edge = c(max.edge-10, max.edge+10))
#SPDE with exponential correlation function
spde = inla.spde2.matern(mesh = mesh1,
alpha = 1.5)
elev.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (beta[1]*coordsDataNew$elevationS)))
plot(elev.spix)
elevsq.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (beta[2]*(coordsDataNew$elevationS)^2)))
plot(elevsq.spix)
plot(mesh1)
is.na(coordsData$obsY)
coordsData[!is.na(coordsData$obsY),]
trp <- coordsData[!is.na(coordsData$obsY),]
dim(trp)
# now let's get the interested covariates
coordsDataNewSubset <- sf::st_as_sf(coordsData[!is.na(coordsData$obsY),],
coords = c("Longitude",
"Latitude"))
max.edge = diff(range(sf::st_coordinates(coordsDataNewSubset)[,1]))/(3*5)
mesh1 = inla.mesh.2d(loc = st_coordinates(coordsDataNewSubset),
max.edge = c(max.edge-10, max.edge+10))
plot(mesh1)
#SPDE with exponential correlation function
spde = inla.spde2.matern(mesh = mesh1,
alpha = 1.5)
cmp <- as.formula("obsY~ - 1 + beta0(1) + site(main= i_year, model = 'iid', n = N) + w2(main = coordinates, model = spde)+ elevOffset(main = elev.spix, model = 'offset')+ elevsqOffset(main = elevsq.spix, model = 'offset')")
coordsDataNew1 <- as.data.frame(coordsDataNewSubset)
coordsDataNew1 <- sp::SpatialPointsDataFrame(coords = coordsDataNew1[, c("Longitude", "Latitude")],
data = coordsDataNew1)
coordsDataNew1
coordsDataNew1
coordsDataNew1 <- as.data.frame(coordsData[!is.na(coordsData$obsY),])
coordsDataNew1 <- sp::SpatialPointsDataFrame(coords = coordsDataNew1[, c("Longitude", "Latitude")],
data = coordsDataNew1)
coordsDataNew1$obsY <- y
coordsDataNew1
lik1 <- inlabru::like(family,
formula = as.formula(paste0("obsY ~ beta0  + site +w2 + elevOffset + elevsqOffset")),
#formula = as.formula(paste0("obsY ~ functionConstants(p, beta0, elev, elevsq, site, w2)")),
# formula = as.formula(paste0("obsY ~   beta0, elev, elevsq, site, w2)")),
data = coordsDataNew1,
Ntrials = 1,
domain = list(coordinates = mesh1)
)
errorIndicated <-  inherits(try(m_bru <- inlabru::bru(cmp,
lik1,
options =
list(
bru_verbose = TRUE,
bru_max_iter=5,
control.fixed = list(expand.factor.strategy = "inla",
mean = 0,
prec.intercept = 0.001,
prec = 1 / (100 * 100)),
control.family = list(link = "logit"),
control.inla = list(int.strategy = "eb"),#, strategy = "gaussian"),
control.compute=list(return.marginals.predictor=TRUE)
)
),
silent = TRUE),
"try-error"
)
m_bru
summary(m_bru)
if(errorIndicated){
ret1 <- data.frame(mld = -Inf,
NA,
NA,
NA,
NA,
NA,
NA,
# rho,
row.names = NULL)
colnames(ret1) <- c("mld", fixedVals, "siteSD", "theta1")
retFixedVals <- rep(1, nrow(coordsData))
ret1 <- cbind(ret1, retFixedVals)
}else{
samples <- inla.posterior.sample(1, m_bru)
fittedValues = c(m_bru$mlik[1,1])
fitted_values <- samples[[1]]$latent[grepl("APredictor",rownames(samples[[1]]$latent) ),1]
# fittedVals <- matrix(fitted_values,
#                      nrow = length(coordsData$Longitude)/N,
#                      ncol = N,
#                      byrow = FALSE)
fittedVals <- plogis(fitted_values)
intercept = samples[[1]]$latent[grepl("beta0:1",rownames(samples[[1]]$latent) ),1]
#elev = samples[[1]]$latent[grepl("elev:1",rownames(samples[[1]]$latent) ),1]
#elevsq = samples[[1]]$latent[grepl("elevsq:1",rownames(samples[[1]]$latent) ),1]
siteSD <-  samples[[1]]$hyperpar[1]
sigma <-  samples[[1]]$hyperpar[2]
theta1 <- samples[[1]]$hyperpar[3]
ret1 <- cbind(fittedValues, intercept,  sigma, theta1, siteSD,  fittedVals)
#theta1 is sigma
colnames(ret1) <- c("mld", fixedVals, "siteSD", "fitVals")
}
ret1
samples[[1]]
?inla.spde2.matern
siteSD
sigma
theta1
spde
#y = zst
inlabruModelFit <- function(x, #matrix
y, #matrix
beta, #parameters fitted from elsewhere, and should be a vector
extraVars,
fixedVals,
family){
# Simulate data
coordsData <- x%>%
as.data.frame()
#convert y to vector
y <- c(extraVars)
#p <- plogis(beta[1] + beta[2]* x[,5] + beta[3]* x[,6])
#p = c(beta)
#coordsData <- cbind(coordsData, p)
colnames(coordsData) <- c("Longitude","Latitude","elevationS", "obsY","i_year" , "forest", "wind" )
# covariate
coordsDataNew <- sf::st_as_sf(coordsData,
coords = c("Longitude",
"Latitude"))
elev.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (beta[1]*coordsDataNew$elevationS)))
elevsq.spix <- SpatialPixelsDataFrame(point =  st_coordinates(coordsDataNew),
data = data.frame(elev = (beta[2]*(coordsDataNew$elevationS)^2)))
# now let's get the interested covariates
coordsDataNewSubset <- sf::st_as_sf(coordsData[!is.na(coordsData$obsY),],
coords = c("Longitude",
"Latitude"))
max.edge = diff(range(sf::st_coordinates(coordsDataNewSubset)[,1]))/(3*5)
mesh1 = inla.mesh.2d(loc = st_coordinates(coordsDataNewSubset),
max.edge = c(max.edge-10, max.edge+10))
#SPDE with exponential correlation function
spde = inla.spde2.matern(mesh = mesh1,
alpha = 1.5)
cmp <- as.formula("obsY~ - 1 + beta0(1) + site(main= i_year, model = 'iid', n = N) + w2(main = coordinates, model = spde)+ elevOffset(main = elev.spix, model = 'offset')+ elevsqOffset(main = elevsq.spix, model = 'offset')")
coordsDataNew1 <- as.data.frame(coordsData[!is.na(coordsData$obsY),])
coordsDataNew1 <- sp::SpatialPointsDataFrame(coords = coordsDataNew1[, c("Longitude", "Latitude")],
data = coordsDataNew1)
coordsDataNew1$obsY <- y
lik1 <- inlabru::like(family,
formula = as.formula(paste0("obsY ~ beta0  + site +w2 + elevOffset + elevsqOffset")),
#formula = as.formula(paste0("obsY ~ functionConstants(p, beta0, elev, elevsq, site, w2)")),
# formula = as.formula(paste0("obsY ~   beta0, elev, elevsq, site, w2)")),
data = coordsDataNew1,
Ntrials = 1,
domain = list(coordinates = mesh1)
)
errorIndicated <-  inherits(try(m_bru <- inlabru::bru(cmp,
lik1,
options =
list(
bru_verbose = TRUE,
bru_max_iter=5,
control.fixed = list(expand.factor.strategy = "inla",
mean = 0,
prec.intercept = 0.001,
prec = 1 / (100 * 100)),
control.family = list(link = "logit"),
control.inla = list(int.strategy = "eb"),#, strategy = "gaussian"),
control.compute=list(return.marginals.predictor=TRUE)
)
),
silent = TRUE),
"try-error"
)
#m_bru <- bru_rerun(m_bru)
#indx <- mesh1$idx$loc
# ret <- matrix(m_bru$summary.fitted.values[indx,"mean"], nrow = length(coordsData$Longitude)/N, ncol = N, byrow = FALSE)
if(errorIndicated){
ret1 <- data.frame(mld = -Inf,
NA,
NA,
NA,
NA,
NA,
NA,
# rho,
row.names = NULL)
colnames(ret1) <- c("mld", fixedVals, "siteSD", "theta1")
retFixedVals <- rep(1, nrow(coordsData))
ret1 <- cbind(ret1, retFixedVals)
}else{
samples <- inla.posterior.sample(1, m_bru)
fittedValues = c(m_bru$mlik[1,1])
fitted_values <- samples[[1]]$latent[grepl("APredictor",rownames(samples[[1]]$latent) ),1]
# fittedVals <- matrix(fitted_values,
#                      nrow = length(coordsData$Longitude)/N,
#                      ncol = N,
#                      byrow = FALSE)
fittedVals <- plogis(fitted_values)
intercept = samples[[1]]$latent[grepl("beta0:1",rownames(samples[[1]]$latent) ),1]
#elev = samples[[1]]$latent[grepl("elev:1",rownames(samples[[1]]$latent) ),1]
#elevsq = samples[[1]]$latent[grepl("elevsq:1",rownames(samples[[1]]$latent) ),1]
siteSD <-  samples[[1]]$hyperpar[1]
sigma <-  samples[[1]]$hyperpar[2]
theta1 <- samples[[1]]$hyperpar[3]
ret1 <- cbind(fittedValues, intercept,  sigma, theta1, siteSD,  fittedVals)
#theta1 is sigma
colnames(ret1) <- c("mld", fixedVals, "siteSD", "fitVals")
}
#ret <- as.matrix(ret)
return(ret1)
}
fit.inlaPar <- function(x ,
y ,
betaMatrix,
extraVarsMatrix,
fixedVals,
family,
nCores){
runFnx <- function(i,
x,
y,
betaMatrix,
extraVarsMatrix,
fixedVals,
family){
res <- inlabruModelFit(x=x,
y=y,
beta = betaMatrix[i, ],
extraVars = extraVarsMatrix[i, ],
fixedVals = fixedVals,
family=family)
return(res)
}
m <- nrow(betaMatrix)
allResults <- parallel::mclapply(1:m,
runFnx,
x,
y,
betaMatrix,
extraVarsMatrix,
fixedVals,
family,
mc.cores = nCores)
ret <- do.call("rbind", allResults)
return(ret)
}
# Set up the R function for use in INLA
nimbleINLA <- nimble::nimbleRcall(
prototype = function(
x=double(2), #x is a matrix
y=integer(2), #y is a matrix
beta=double(2), # beta is a matrix
extraVarsMatrix = double(2),
fixedVals = character(1, default = c("intercept", "sigma","theta1")),
#interInModel = double(0, default = 1),
family = character(0, default = "binomial"),
nCores = integer(0, default = 1)
) {},
returnType = double(2), # outcome is a vector
Rfun = 'fit.inlaPar'
)
zst <- apply(dataSimulated$y[indxOfSitesObs,], 1, function(t){
r <-sum(t)
rt <- as.numeric(r>0)
#rt <- ifelse(rt==0, NA, rt)
return(rt)
})
#text if it works
inlabruModelFit(x, y = x, beta = c(2, -2), extraVars = zst, fixedVals = c("intercept", "sigma","theta1"), family = "binomial")
# NIMBLE code
code <-nimbleCode({
# Specify priors
alpha0 ~ dnorm(0, 0.1)
beta0 ~ dnorm(0, 0.1)
for(v in 1:2){
alpha[v] ~ dnorm(0, 0.1)
beta[v] ~ dnorm(0, 0.1)
}
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
logit(p[site.tag, visit.tag]) <- alpha0 + alpha[1]*forest[site.tag] + alpha[2]*wind[site.tag, visit.tag]
}
}
###### Occupancy model
for(site.tag in 1:nsites){
logit(psi[site.tag]) <- beta0 + beta[1]*elev[site.tag] + beta[2]*elevsq[site.tag] #+ eta[site.tag]
}
for(site.tag in 1:nsites){
z[site.tag] ~ dbin(size = 1, prob = psi[site.tag])
}
#eta[1:nsites] ~ dcar_normal(adj[1:16], weights[1:16], num[1:50], tau = sigma)
# Observation model
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
y[site.tag, visit.tag] ~ dbin(size = 1, prob = z[site.tag]*p[site.tag, visit.tag])
}
}
#
sigma ~ dgamma(1, 0.0001)
theta1 ~ dunif(-1000, 1000)
#derived quantity
psi.fs <- sum(z[1:nsites])/nsites
})
## Parameterising the nimble model
library(spdep)
coordgrid <- cbind(dataSimulated$xcoord[indxOfSitesObs], dataSimulated$ycoord[indxOfSitesObs])
neigh <- dnearneigh(coordgrid,
d1 = 0,
d2 = sqrt(2)*1000 + 1)
winnb <- nb2WB(neigh)
str(winnb)
zst <- apply(dataSimulated$y[indxOfSitesObs,], 1, function(t){
r <-sum(t)
rt <- as.numeric(r>0)
rt <- ifelse(rt==0, NA, rt)
return(rt)
})
#Data
inla_data <- list(y = dataSimulated$y[indxOfSitesObs,],
forest = standardize(dataSimulated$forest[indxOfSitesObs]),
wind = dataSimulated$wind[indxOfSitesObs,],
elev = dataSimulated$elevationS[indxOfSitesObs],
elevsq = (dataSimulated$elevationS[indxOfSitesObs])^2,
adj = winnb$adj,
weights = winnb$weights,
num = winnb$num,
z = zst)
#Constants
const <- list(N = dataSimulated$nsurveys,
nvisits = dataSimulated$nsurveys,
nsites = length(dataSimulated$xcoord[indxOfSitesObs])
)
#zst <- apply(inla_data$y, 1, max)
#zst[is.na(zst)] <- 1
# Initial values
idm_inits <- function(){list(p = matrix(runif(const$N * const$nsites, 0, 1), nrow = const$nsites, ncol= const$N),
alpha = c(-0.2, 0.2),
alpha0 = -0.405,
beta = c(0.1, 0.1),
beta0 = 1,
sigma = 1,
eta = rep(0, const$nsites),
psi = runif(const$nsites, 0, 1)
)
}
initsList <- idm_inits()
occSpatialModel <- INLAWiNimDataGeneratingTargetDivide(data = c("y"),
covariate = x,
code = code,
family = "binomial",
modelData = inla_data,
modelConstants = const,
modelInits = idm_inits,
nimbleINLA = nimbleINLA,
inlaMCMC = "importanceSampling",
samplerControl = list( scale = sqrt(10),
adaptive = TRUE,
sliceMaxSteps = 30,
extraVars = c("z"),
initMean = rnorm(2,0,1),
initCov= 1*diag(2),
proposal = "normal",
latentIsDependent = FALSE,
spatioTemporal = TRUE,
nCores = 1),#if nCores>1, we cannot run the code o windows
parametersToMonitor = list(mcmc = c("alpha0","alpha", "beta[1]","beta[2]", "z"),
mcmcINLA = c("beta0", "sigma", "theta1"),
inla = c("beta0",  "sigma", "theta1"),
additionalPars = c("psi.fs")),
mcmcConfiguration = list(n.chains = 5,
n.iterations = 300,
n.burnin = 200,
n.thin = 2,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
)
occSpatialModel$isINLA$mcmc.out$summary
occSpatialModel$isINLA$mcmc.out$samples
