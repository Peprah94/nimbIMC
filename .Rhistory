x,
y,
betaMatrix,
extraVarsMatrix,
fixedVals,
family){
res <- inlabruModelFit(x=x,
y=y,
beta = betaMatrix[i, ],
extraVars = extraVarsMatrix[i, ],
fixedVals = fixedVals,
family=family)
return(res)
}
m <- nrow(betaMatrix)
allResults <- parallel::mclapply(1:m,
runFnx,
x,
y,
betaMatrix,
extraVarsMatrix,
fixedVals,
family,
mc.cores = nCores)
ret <- do.call("rbind", allResults)
return(ret)
}
# Set up the R function for use in INLA
nimbleINLA <- nimble::nimbleRcall(
prototype = function(
x=double(2), #x is a matrix
y=integer(2), #y is a matrix
beta=double(2), # beta is a matrix
extraVarsMatrix = double(2),
fixedVals = character(1, default = c("intercept", "sigma","theta1")),
#interInModel = double(0, default = 1),
family = character(0, default = "binomial"),
nCores = integer(0, default = 1)
) {},
returnType = double(2), # outcome is a vector
Rfun = 'fit.inlaPar'
)
zst <- apply(dataSimulated$y[indxOfSitesObs,], 1, function(t){
r <-sum(t)
rt <- as.numeric(r>0)
#rt <- ifelse(rt==0, NA, rt)
return(rt)
})
mean(zst)
# NIMBLE code
code <-nimbleCode({
# Specify priors
alpha0 ~ dnorm(0, 0.1)
beta0 ~ dnorm(0, 0.1)
for(v in 1:2){
alpha[v] ~ dnorm(0, 0.1)
beta[v] ~ dnorm(0, 0.1)
}
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
logit(p[site.tag, visit.tag]) <- alpha0 + alpha[1]*forest[site.tag] + alpha[2]*wind[site.tag, visit.tag]
}
}
###### Occupancy model
for(site.tag in 1:nsites){
logit(psi[site.tag]) <- beta0 + beta[1]*elev[site.tag] + beta[2]*elevsq[site.tag] #+ eta[site.tag]
}
for(site.tag in 1:nsites){
z[site.tag] ~ dbin(size = 1, prob = psi[site.tag])
}
#eta[1:nsites] ~ dcar_normal(adj[1:16], weights[1:16], num[1:50], tau = sigma)
# Observation model
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
y[site.tag, visit.tag] ~ dbin(size = 1, prob = z[site.tag]*p[site.tag, visit.tag])
}
}
#
sigma ~ dgamma(1, 0.0001)
theta1 ~ dunif(-1000, 1000)
#derived quantity
psi.fs <- sum(z[1:nsites])/nsites
})
## Parameterising the nimble model
library(spdep)
coordgrid <- cbind(dataSimulated$xcoord[indxOfSitesObs], dataSimulated$ycoord[indxOfSitesObs])
neigh <- dnearneigh(coordgrid,
d1 = 0,
d2 = sqrt(2)*1000 + 1)
winnb <- nb2WB(neigh)
str(winnb)
zst <- apply(dataSimulated$y[indxOfSitesObs,], 1, function(t){
r <-sum(t)
rt <- as.numeric(r>0)
rt <- ifelse(rt==0, NA, rt)
return(rt)
})
#Data
inla_data <- list(y = dataSimulated$y[indxOfSitesObs,],
forest = standardize(dataSimulated$forest[indxOfSitesObs]),
wind = dataSimulated$wind[indxOfSitesObs,],
elev = dataSimulated$elevationS[indxOfSitesObs],
elevsq = (dataSimulated$elevationS[indxOfSitesObs])^2,
adj = winnb$adj,
weights = winnb$weights,
num = winnb$num,
z = zst)
#Constants
const <- list(N = dataSimulated$nsurveys,
nvisits = dataSimulated$nsurveys,
nsites = length(dataSimulated$xcoord[indxOfSitesObs])
)
#zst <- apply(inla_data$y, 1, max)
#zst[is.na(zst)] <- 1
# Initial values
idm_inits <- function(){list(p = matrix(runif(const$N * const$nsites, 0, 1), nrow = const$nsites, ncol= const$N),
alpha = c(-0.2, 0.2),
alpha0 = -0.405,
beta = c(0.1, 0.1),
beta0 = 1,
sigma = 1,
eta = rep(0, const$nsites),
psi = runif(const$nsites, 0, 1)
)
}
initsList <- idm_inits()
data = c("y")
data = c("y")
covariate = x
code = code
family = "binomial"
modelData = inla_data
modelConstants = const
modelInits = idm_inits
nimbleINLA = nimbleINLA
inlaMCMC = "importanceSampling"
samplerControl = list( scale = sqrt(10),
adaptive = TRUE,
sliceMaxSteps = 30,
extraVars = c("z"),
initMean = rnorm(5,0,1),
initCov= 1*diag(5),
proposal = "normal",
latentIsDependent = FALSE,
spatioTemporal = TRUE,
nCores = 1)#if nCores>1, we cannot run the code o windows
parametersToMonitor = list(mcmc = c("alpha0","alpha", "beta[1]","beta[2]", "z"),
mcmcINLA = c("beta0", "sigma", "theta1"),
inla = c("beta0",  "sigma", "theta1"),
additionalPars = c("psi.fs"))
mcmcConfiguration = list(n.chains = 2,
n.iterations = 20,
n.burnin = 2,
n.thin = 2,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
#extract necessary variables
x <- covariate # must be a matrix
y <- data # must be a vector
family <- family
fixedVals <- parametersToMonitor$inla
target <- parametersToMonitor$mcmc
targetMCMC <- parametersToMonitor$mcmcINLA
additionalPars <- parametersToMonitor$additionalPars
initsList <- modelInits()
#Create the model in nimble
mwtc <- nimble::nimbleModel(code,
data = modelData,
constants = modelConstants,
inits = initsList)
# Create the model in C
Cmwtc <- nimble::compileNimble(mwtc,
showCompilerOutput = FALSE) #Have issues compiling
#create list to return
retList <- list()
samplerControl$nimbleINLA <- nimbleINLA
samplerControl$family <- family
samplerControl$fixedVals <- fixedVals
samplerControl$timeIndex <- ceiling(mcmcConfiguration[["n.iterations"]]/(mcmcConfiguration[["n.chains"]]))
samplerControl$nSteps <- mcmcConfiguration[["n.chains"]]
if(!is.null(additionalPars)){samplerControl$additionalPars <- additionalPars}
if(is.null(samplerControl$latentIsDependent)) samplerControl$latentIsDependent <- TRUE
samplerControl = list( scale = sqrt(10),
adaptive = TRUE,
sliceMaxSteps = 30,
extraVars = c("z"),
initMean = rnorm(5,0,1),
initCov= 1*diag(5),
proposal = "normal",
latentIsDependent = TRUE,
spatioTemporal = TRUE,
nCores = 1)#if nCores>1, we cannot run the code o windows
samplerControl$nimbleINLA <- nimbleINLA
samplerControl$family <- family
samplerControl$fixedVals <- fixedVals
samplerControl$timeIndex <- ceiling(mcmcConfiguration[["n.iterations"]]/(mcmcConfiguration[["n.chains"]]))
samplerControl$nSteps <- mcmcConfiguration[["n.chains"]]
if(!is.null(additionalPars)){samplerControl$additionalPars <- additionalPars}
if(is.null(samplerControl$latentIsDependent)) samplerControl$latentIsDependent <- TRUE
# there are instances, such as spatio-temporal effects where we want to return samples of linear effect
# we then need to extract such variables
if(!is.null(samplerControl$spatioTemporal)){
samplerControl$linearPred <- Cmwtc$getDependencies(nodes = fixedVals, includeData = FALSE, self = FALSE, determOnly = TRUE)
samplerControl$returnLinearPred <- TRUE
} else {
samplerControl$returnLinearPred <- FALSE
samplerControl$linearPred <- NULL
}
fam <- family
model <. mwtc
model <- mwtc
control = samplerControl
#control list extraction
nimbleINLA <- extractControlElement(control, 'nimbleINLA',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
proposal <- extractControlElement(control, 'proposal',  character())
initMean <- extractControlElement(control, 'initMean',  NULL)
initCov <- extractControlElement(control, 'initCov',  NULL)
initModel <- extractControlElement(control, 'initModel',  FALSE)
timeIndex <- extractControlElement(control, 'timeIndex',  double()) #Nt
nSteps <- extractControlElement(control, 'nSteps',  integer()) #Number of steps at each direction
nCores <- extractControlElement(control, 'nCores',  NULL)
dfTdist <- extractControlElement(control, 'dfTdist',  NULL)
adaptive <- extractControlElement(control, 'adaptive',  TRUE)
additionalPars <- extractControlElement(control, 'additionalPars',  NULL)
latentIsDependent <- extractControlElement(control, 'latentIsDependent',  TRUE)
betaWts <- extractControlElement(control, 'betaWts',  NULL)
latentWts <- extractControlElement(control, 'latentWts',  NULL)
linearPred <- extractControlElement(control, 'linearPred',  NULL)
returnLinearPred <- extractControlElement(control, 'returnLinearPred',  FALSE)
#latentIsDependent must be logical
if(!is.logical(latentIsDependent)) stop("latentIsDependent must be either TRUE or FALSE, indicating whether the latent variable is dependent on the other MCMC parameters.")
if(!is.logical(adaptive)) stop("adaptive must be logical: either TRUE or FALSE, indicating whether the parameters of the proposal distribution are adapted or not.")
#returnLinear must be logical
if(!is.logical(returnLinearPred)) stop("return Linear predictor must either be TRUE or FALSE")
# if returnLinear is TRUE, linear pred must not be false
if(isTRUE(returnLinearPred) & is.null(linearPred)) stop("return Linear predictor cannot be TRUE and the Linear predictor variables be NULL")
#Note
# In the original paper:
## timeIndex = Nt
## nSteps = t
isDic <- sapply(target, function(x){
all(model$isDiscrete(nodes = x))==TRUE
})
nTarget <- length(target)
dataVar <- y
if(!is.character(y)) stop("'y' must be the node nae for the data variable")
y <- model[[y]]
if(nTarget < 2) stop("Function only works for more than two target variables")
discreteTarget <- target[isDic]
isNotDiscreteTarget <- target[!isDic]
discreteTarget
isNotDiscreteTarget
#Parameterisations for continuous vars
nTargetCont <- length(model$expandNodeNames(nodes = isNotDiscreteTarget))
if(is.null(initMean)) initMean <- rep(0, nTargetCont)
if(is.null(initCov)) initCov <- diag(nTargetCont)
if(is.null(nCores)) nCores <- 1
if(is.null(dfTdist)) dfTdist <- 1
if(!proposal %in% c("normal", "studentT", "prior")) stop("Proposal distribution must be either 'normal', 'student T' and 'prior' distributions.")
if(proposal == "prior") adaptive <- FALSE
#yExpand <- model$expandNodeNames(y, returnScalarComponents = TRUE)
#y <- model[[y]]
#y <- c(nimble::values(model, yExpand))
my_initializeModel <- initializeModel(model, silent = TRUE)
#save posterior samples
#modelVals = modelValues(model, m = 1)
if(is.null(additionalPars)){
vars <- model$getVarNames(nodes = c(fixedVals, target))
}else{
vars <- model$getVarNames(nodes = c(fixedVals, target, additionalPars))
}
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(length(x) == 0){
#length(model$vars)
ret <- 1 #c(1, timeIndex)
# return(ret)
}else{
ret <- x #c(x, timeIndex)
}
return(ret)
} )
#size$beta <- 4
if("gamma" %in% names) stop("change the variable name of gamma.")
# Add names and dimensions for wts and gamma
names <- c(names, "wts", "gamma","logLike", "wtsLatent", "betaWeights", "latentWeights")
type <- c(type, rep("double", 1), rep("double",1),
rep("double", 1), rep("double", 1), rep("double", 1), rep("double", 1))
size$wts <- nSteps
size$wtsLatent <- nSteps
size$gamma <- nSteps
#size$gamma2 <- nSteps
size$logLike <- nSteps
size$betaWeights <- 1
size$latentWeights <- 1
#size$logLike2 <- nSteps
#print(1)
#model values to save results
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
mvWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# create storage for mean and covariance matrices
muStep <- matrix(0, nrow = nSteps+1, ncol = nTargetCont)
sigmaStep <- array(0, dim = c(nTargetCont, nTargetCont, nSteps+1))
impSampINLAstepFnx <- nimbleFunctionList(importanceSamplingStepVirtual)
#for(iNode in seq_along(nodes)){
# beta <- target
for(iNode in 1:nSteps){
impSampINLAstepFnx[[iNode]] <- impSampINLAstepMultiple(model,
mvEWSamples,
mvWSamples,
fixedVals,
iNode,
x, #covariates
y, #response variable
# interInModel,
fam,
proposal, #proposal distribution
isNotDiscreteTarget, # continuous variables which we specify normal or T-distribution for
discreteTarget, # Discrete random variables
timeIndex,
vars,
nCores,
dfTdist,
adaptive,
additionalPars,
dataVar,
latentIsDependent,
returnLinearPred,
linearPred
)
}
muStep[1,] <- initMean
sigmaStep[,,1] <- initCov
m <- timeIndex
iNode = 1
#Note
# iNode = Nt
#timeIndex = number of samples at each it = m
m <- timeIndex
#check if it is the first index
isFirstNode <- iNode == 1
#set continuous vars to beta and discrete vars to disc
beta <- isNotDiscreteTarget
disc <- discreteTarget
# setting up parameters
N <- length(fixedVals) #length of INLA parameters
ess <- 0 # initialise effective sample size
#store simulated values of beta
betaNames <- model$expandNodeNames(nodes = beta)
nBetaSims <- length(betaNames) #dimeension of beta
betaVals <- rep(0, length = length(betaNames)) #vector to store beta values
depsbetaNames <- model$getDependencies(betaNames, self = FALSE, determOnly = TRUE)
betaNames
depsbetaNames
#store simulated values of discrete (latent) target
discTarNames <- model$expandNodeNames(nodes = discreteTarget)
nDiscTarNames <- length(discTarNames)
discTarVals <- rep(0, length = nDiscTarNames)
#check if the discrete random variable is binary
isLatentBinary <- all(model$isBinary(discTarNames) == TRUE)
isLatentBinary
#print(isLatentBinary)
# if(isLatentBinary == TRUE){
#select those that are data
binNodesToSimulate <- discTarNames[!model$isData(discTarNames)]
nBinNodesToSimulate <- length(binNodesToSimulate)
binNodesToFix <- discTarNames[model$isData(discTarNames)]
nBinNodesToFix <- length(binNodesToFix)
binNodesToSimulateVals <- rep(0, length = nBinNodesToSimulate)
binNodesToFixVals <- rep(1, length = nBinNodesToFix)
#get dependencies of both parameters. Will be used to calculate weights at each time
allISparameters <- c(beta, discreteTarget)
allISparametersDeps <-   model$getDependencies(allISparameters)
# store updated mean and sigma
mu <- rep(0, length = nBetaSims)
sigma <- matrix(0, nrow=nBetaSims, ncol = nBetaSims)
# store weights and gamma
wts <- numeric(m)
gamma <- numeric(m)
wtsLatent <- numeric(m)
betaWts <- numeric(m)
# Create a cummulative indexing to calculate nugget
nugget <- seq(1, iNode, 1) #Cummulative index for N's
nNugget <- length(nugget) #length of N's
nugs <- numeric(nNugget)
# Estimate increasing indices
indInc <- (iNode - 1)*m #sum from N1 to Nt-1
sumNt <- m + indInc
#beta estimates at iteration t
betaEsts <- matrix(0, nrow = m, ncol = nBetaSims)
discTarEsts <- matrix(0, nrow = m, ncol = nDiscTarNames)
# Get beta estimates from steps 1 to Nt
betaEstsUpd <- matrix(0, nrow = sumNt, ncol = (nBetaSims+1))
rts <- matrix(0, nrow = sumNt, ncol = nBetaSims)
rtsUpd <- matrix(0, nrow = sumNt, ncol = nBetaSims)
muEsts <- matrix(0, nrow = sumNt, ncol = nBetaSims)
#check if we have additional Parameters (especially derived quantities) to save
isNullAdditionalPars <- is.null(additionalPars)
fixedValsStoreMatrix <- matrix(0, nrow = timeIndex, ncol = length(fixedVals))
lenLinPred <- length(linearPred)
if(returnLinearPred) linearPredVals <- numeric(length(linearPred))
setwd("C:/GitHub/fishyIPMs/ModelFitting")
setwd("C:/GitHub/fishyIPMs")
#load packages
library(nimble)
library(dplyr)
library(readr)
library(reshape2)
# set working directory.
#change this for your particular application
setwd("C:/GitHub/fishyIPMs")
# load Population data
popnData <- read_delim("dataset/Example1.csv",
delim = ";",
escape_double = FALSE,
trim_ws = TRUE)
colnames(popnData)[c(2:5,8,10,12,16:25,29:30)] <- c("climateZone",
"lakeNumber",
"lineNumber",
"date",
"lakeName",
"gillnetNumber",
"gillnetMeshSize",
"speciesName",
"fishLength",
"fishWeight",
"fishFat",
"gonadWeight",
"sex",
"maturationStage",
"maturation",
"revisedMaturation",
"stomachContent",
"otoliothRadius",
"captureAge")
# remove NAs from some selected columns
popnData <- popnData[complete.cases(popnData[, c("maturationStage", "maturation")]),] %>%
dplyr::mutate(maturationStage = as.numeric(maturationStage),
maturation = as.numeric(maturation))
# Explore the relationship
r <- c(popnData[, 22])$maturationStage
s <- c(popnData[, 23])$maturation
table(s,r) #what is the relationship between maturation and maturation stage?
# Individual dataset
indData <- read_delim("dataset/Example2.csv",
delim = ";",
escape_double = FALSE,
trim_ws = TRUE)
colnames(indData)[c(1:6,8:34)] <- c("lengthYrBefore",
"legthAtAgeThisYear",
"yearGrowthOcc",
"ageGrowthOcc",
"ageAtYr",
"fishID",
"climateZone",
"locationNumber",
"metersAboveSea",
"lineNumber",
"date",
"year",
"period",
"lakeName",
"fishAge",
"fishLength",
"fishWeight",
"sex",
"maturationStage",
"maturation",
"ageAtGrowth",
"growth",
"instanteneousGrowth",
"capturePerUnitEffort",
"temperatureMeanInMay",
"temperatureMeanInJune",
"temperatureMeanInJuly",
"precipitationSumInMay",
"precipitationSumInJune",
"precipitationSumInJuly",
"temperatureMeanInSummer",
"precipitationSumDuringSummer",
"NAOwinterIndex")
indData <- indData[complete.cases(indData[, c("maturationStage", "maturation")]),] %>%
dplyr::mutate(maturationStage = as.numeric(maturationStage),
maturation = as.numeric(maturation),
presence = 1)
indData$locationNumber
unique(indData$locationNumber)
# catchment variables
catchmentVars <- read_csv("dataset/NO_all_vars_over_catchments.csv")
colnames(catchmentVars)
unique(catchmentVars$vatnLnr)
unique(indData$locationNumber)
# Individual dataset
indData <- read_delim("dataset/Example2.csv",
delim = ";",
escape_double = FALSE,
trim_ws = TRUE)
indData$loknr
unique(indData$loknr)
unique(indData$navn)
