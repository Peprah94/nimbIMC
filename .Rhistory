res = INLA::inla(y ~ formula,
data = data,
family = family,
verbose=FALSE,
control.predictor = list(compute = TRUE))
#fitted_values = res$summary.fitted.values[,"mean"]
fitted_values = c(res$mlik[1,1])
#intercept = INLA::inla.emarginal(function(x) x,res$marginals.fixed[[1]])
if(interInModel == 1){
intercept = INLA::inla.emarginal(function(x) x,res$marginals.fixed[[1]])
}else{
intercept = 1
}
precision = INLA::inla.emarginal(function(x) x,res$marginals.hyper[[1]])
ret <- data.frame(mld = fitted_values, intercept, precision,
row.names = NULL)
colnames(ret) <- c("mld", fixedVals)
ret <- as.matrix(ret)
return(ret)
}
nimbleINLA <- nimble::nimbleRcall(
prototype = function(
x=double(2), #x is a matrix
y=double(1), #y is a vector
beta=double(1), # beta is a vector
fixedVals = character(1, default = c("a", "sigma")),
interInModel = double(0, default = 1),
family = character(0, default = "gaussian")
) {},
returnType = double(2), # outcome is a vector
Rfun = 'fit.inla'
)
nimbleINLA(data$x, data$y, c(2,1))
x <- data$x
y <- data$y
interInModel <- 1
fixedVals = c("a", "sigma")
Cmwtc <- nimble::compileNimble(mwtc,
showCompilerOutput = FALSE)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
cwtm$run(beta = c(1, 1), interInModel = 3)
cwtm$mvEWSamples
buildINLAmodel <- nimbleFunction(
name = 'buildINLAmodel',
setup = function(model, fam, x, y, control) {
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
#save posterior samples
#modelVals = modelValues(model, m = 1)
vars <- model$getVarNames(nodes = fixedVals)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(is.null(dim(x))){
return(1)
}else(
x
)
} )
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interModel,
fam)
#}
#essVals <- rep(0, length(nodes))
lastLogLik <- -Inf
},
run = function(beta=double(1), # beta is a vector
interInModel = double(0, default = 1)) {
returnType(double())
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
logL <- out
if(logL == -Inf) {lastLogLik <<- logL; return(logL)}
if(is.nan(logL)) {lastLogLik <<- -Inf; return(-Inf)}
if(logL == Inf)  {lastLogLik <<- -Inf; return(-Inf)}
lastLogLik <<-  logL
return(logL)
},
methods = list(
getLastLogLik = function() {
return(lastLogLik)
returnType(double())
},
setLastLogLik = function(lll = double()) {
lastLogLik <<- lll
},
getMVest = function(){
return(inlaStepFunctions[[1]]$mvEWSamples)
returnType(double())
}
)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals)
fam = "gaussian"
y= data$y
x = data$x
model = mwtc
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
#save posterior samples
#modelVals = modelValues(model, m = 1)
vars <- model$getVarNames(nodes = fixedVals)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(is.null(dim(x))){
return(1)
}else(
x
)
} )
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interModel,
fam)
lastLogLik <- -Inf
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
interInModel = 1
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
nimbleINLA(data$x, data$y, c(2,1))
fam
beta
beta = c(-1, 1)
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
interInModel
beta
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interModel,
fam)
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam)
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
# Bootstrap filter as specified in Doucet & Johnasen '08,
# uses weights from previous time point to calculate likelihood estimate.
inlaFStep <- nimbleFunction(
name = 'inlaFStep',
contains = inlaStepVirtual,
setup = function(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam
) {
#res <- inlaModel(x, y, beta, fixedVals, interInModel, family = fam)
N <- length(fixedVals)
vals <- rep(0, N)
},
run = function(beta = double(1), # beta is a vector
interInModel = double(0, default = 1)) {
returnType(double(0))
#out <- numeric(1, init=FALSE)
# vals <-
#ll <-
res <- nimbleINLA(x, y, beta, fixedVals, interInModel, family = fam)
# save results
for(i in 1:N){
vals[i] <<- res[1, i + 1]
}
lll <- res[1,1]
values(model, fixedVals) <<- vals
copy(model, mvEWSamples, nodes = fixedVals, row = 1)
out <- lll
return(out)
}
)
buildINLAmodel <- nimbleFunction(
name = 'buildINLAmodel',
setup = function(model, fam, x, y, control) {
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
#save posterior samples
#modelVals = modelValues(model, m = 1)
vars <- model$getVarNames(nodes = fixedVals)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(is.null(dim(x))){
return(1)
}else(
x
)
} )
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam)
#}
#essVals <- rep(0, length(nodes))
lastLogLik <- -Inf
},
run = function(beta=double(1), # beta is a vector
interInModel = double(0, default = 1)) {
returnType(double())
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
logL <- out
if(logL == -Inf) {lastLogLik <<- logL; return(logL)}
if(is.nan(logL)) {lastLogLik <<- -Inf; return(-Inf)}
if(logL == Inf)  {lastLogLik <<- -Inf; return(-Inf)}
lastLogLik <<-  logL
return(logL)
},
methods = list(
getLastLogLik = function() {
return(lastLogLik)
returnType(double())
},
setLastLogLik = function(lll = double()) {
lastLogLik <<- lll
},
getMVest = function(){
return(inlaStepFunctions[[1]]$mvEWSamples)
returnType(double())
}
)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
buildINLAmodel <- nimbleFunction(
name = 'buildINLAmodel',
setup = function(model, fam, x, y, control) {
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
#save posterior samples
#modelVals = modelValues(model, m = 1)
vars <- model$getVarNames(nodes = fixedVals)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(is.null(dim(x))){
return(1)
}else(
x
)
} )
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam)
#}
#essVals <- rep(0, length(nodes))
lastLogLik <- -Inf
},
run = function(beta=double(1), # beta is a vector
interInModel = double(0, default = 1)) {
returnType(double())
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
logL <- out
if(logL == -Inf) {lastLogLik <<- logL; return(logL)}
if(is.nan(logL)) {lastLogLik <<- -Inf; return(-Inf)}
if(logL == Inf)  {lastLogLik <<- -Inf; return(-Inf)}
lastLogLik <<-  logL
return(logL)
},
methods = list(
getLastLogLik = function() {
return(lastLogLik)
returnType(double())
},
setLastLogLik = function(lll = double()) {
lastLogLik <<- lll
}
)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
cwtm$run(beta = c(1, 1), interInModel = 3)
cwtm$mvEWSamples
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam)
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
inlaStepFunctions[[1]]$mvEWSamples
rr <- inlaStepFunctions[[1]]$mvEWSamples
buildINLAmodel <- nimbleFunction(
name = 'buildINLAmodel',
setup = function(model, fam, x, y, control) {
inlaModel <- extractControlElement(control, 'fit.inla',  NULL)
fixedVals <- extractControlElement(control, 'fixedVals',  double())
#save posterior samples
#modelVals = modelValues(model, m = 1)
vars <- model$getVarNames(nodes = fixedVals)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
size <- lapply(size, function(x){
if(is.null(dim(x))){
return(1)
}else(
x
)
} )
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
fixedVals <- model$expandNodeNames(fixedVals)
# vals <- rep(0, length(fixedVals))
#for(i in seq_along(fixedVals)){
# values(model, fixedVals[i]) <- c(res[1,fixedVals[i]])
#}
#vals <- c(res[1,fixedVals])
inlaStepFunctions <- nimbleFunctionList(inlaStepVirtual)
#for(iNode in seq_along(nodes)){
inlaStepFunctions[[1]] <- inlaFStep(model,
mvEWSamples,
fixedVals,
# inlaModel,
x,
y,
interInModel,
fam)
#}
#essVals <- rep(0, length(nodes))
lastLogLik <- -Inf
},
run = function(beta=double(1), # beta is a vector
interInModel = double(0, default = 1)) {
returnType(double())
# for(i in seq_along(fixedVals)){
#   mvEWSamples[[fixedVals[i]]][1] <<- vals[i]
# }
out <- inlaStepFunctions[[1]]$run(beta, interInModel = interInModel)
rr <- inlaStepFunctions[[1]]$mvEWSamples
logL <- out
if(logL == -Inf) {lastLogLik <<- logL; return(logL)}
if(is.nan(logL)) {lastLogLik <<- -Inf; return(-Inf)}
if(logL == Inf)  {lastLogLik <<- -Inf; return(-Inf)}
lastLogLik <<-  logL
return(logL)
},
methods = list(
getLastLogLik = function() {
return(lastLogLik)
returnType(double())
},
setLastLogLik = function(lll = double()) {
lastLogLik <<- lll
},
getMVest = function(){
return(rr)
returnType(double())
}
)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
source("~/Documents/GitHub/myphdthesis/R/buildINLAModel.R", echo=TRUE)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
source("~/Documents/GitHub/myphdthesis/R/buildINLAModel.R", echo=TRUE)
ret <- buildINLAmodel(mwtc,
fam = "gaussian",
x = data$x, y= data$y,
control = list(fit.inla = nimbleINLA,
fixedVals = fixedVals))
cwtm <- compileNimble(ret)
cwtm$run(beta = c(1, 1), interInModel = 3)
cwtm$mvEWSamples
cwtm$lastLogLik
