#| label: table_updated
#| fig-cap: The weighted and unweighted samples from the particle Filter
#| warning: false
#| message: false
#|
head(plotDataUpdated)%>%
kbl() %>%
kable_material(c("striped", "hover"))
dfDataBaseline <- plotDataBaseline%>%
reshape2::melt(., id.vars = "t")
dfDataReduced <- plotDataReduced%>%
reshape2::melt(., id.vars = "t")
dfDataUpdated <- plotDataUpdated%>%
reshape2::melt(., id.vars = "t")
plotData <- rbind(dfDataBaseline,
dfDataReduced ,
dfDataUpdated)
plotData%>%
ggplot()+
geom_line(mapping = aes(x = t, y = value, linetype = variable, col = variable))+
ylab("Latent samples from PFs")+
theme_classic()
# simulate some data
t <- 50; mu_0 <- 1
x <- rnorm(1 ,mu_0, 1)
y <- rnorm(1, x, 1)
a <- 0.5; b <- 1; c <- 1
for(i in 2:t){
x[i] <- rnorm(1, x[i-1] * a + b,1)
y[i] <- rnorm(1, x[i] * c, 1)
}
#Set the number of iteration
parNum <- 5000
baseModelCode <- nimbleCode({
x[1] ~ dnorm(mu_0, 1)
y[1] ~ dnorm(x[1], 1)
for(i in 2:t){
x[i] ~ dnorm(x[i-1] * a + b, 1)
y[i] ~ dnorm(x[i] * c, 1)
}
a ~ dunif(0, 1)
b ~ dnorm(0, 1)
c ~ dnorm(1,1)
mu_0 ~ dnorm(0, 1)
})
baseTimeModel <- nimbleModel(baseModelCode, constants = list(t = t),
data <- list(y = y), check = FALSE )
# Set parameter values and compile the model
#baseTimeModel$a <- 0.5
#baseTimeModel$b <- 1
#baseTimeModel$c <- 1
#baseTimeModel$mu_0 <- 1
cbaseTimeModel <- compileNimble(baseTimeModel)
baseTimeConf <- configureMCMC(baseTimeModel) # default MCMC configuration
# Add random walk PMCMC sampler with particle number optimization.
library(nimbleSMC)
baseTimeConf$addSampler(target = c("a", "b", "c", "mu_0"), type = "RW_PF_block",
control = list(propCov= diag(4), adaptScaleOnly = FALSE,
latents = "x", pfOptimizeNparticles = TRUE, filterType = "auxilliary"))
# Build auxiliary filter
Rmcmc <- buildMCMC(baseTimeConf)
# Compile
cmcmc <- compileNimble(baseTimeModel,Rmcmc,
#project = cbaseTimeModel,
resetFunctions = TRUE
)
#cmcmc$Rmcmc$run(10000)
# Run the MCMC
mcmc.out <- runMCMC(cmcmc,
niter = 10000,
nchains =3,
nburnin = 5000,
#inits = initsList,
#thin = 5,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE
)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
cbaseTimeModel <- compileNimble(baseTimeModel)
cbaseTimeModel <- compileNimble(baseTimeModel)
baseTimeConf <- configureMCMC(baseTimeModel) # default MCMC configuration
# Add random walk PMCMC sampler with particle number optimization.
library(nimbleSMC)
baseTimeConf$addSampler(target = c("a", "b", "c", "mu_0"), type = "RW_PF_block",
control = list(propCov= diag(4), adaptScaleOnly = FALSE,
latents = "x", pfOptimizeNparticles = TRUE, filterType = "auxilliary"))
Rmcmc <- buildMCMC(baseTimeConf)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
baseModelCode <- nimbleCode({
x[1] ~ dnorm(mu_0, 1)
y[1] ~ dnorm(x[1], 1)
for(i in 2:t){
x[i] ~ dnorm(x[i-1] * a + b, 1)
y[i] ~ dnorm(x[i] * c, 1)
}
a ~ dunif(0, 1)
b ~ dnorm(0, 1)
c ~ dnorm(1,1)
mu_0 ~ dnorm(0, 1)
})
baseTimeModel <- nimbleModel(baseModelCode, constants = list(t = t),
data <- list(y = y), check = FALSE )
# Set parameter values and compile the model
#baseTimeModel$a <- 0.5
#baseTimeModel$b <- 1
#baseTimeModel$c <- 1
#baseTimeModel$mu_0 <- 1
cbaseTimeModel <- compileNimble(baseTimeModel)
baseTimeConf <- configureMCMC(baseTimeModel) # default MCMC configuration
# Add random walk PMCMC sampler with particle number optimization.
library(nimbleSMC)
baseTimeConf$addSampler(target = c("a", "b", "c", "mu_0"), type = "RW_PF_block",
control = list(propCov= diag(4), adaptScaleOnly = FALSE,
latents = "x", pfOptimizeNparticles = TRUE, filterType = "auxilliary"))
# Build auxiliary filter
Rmcmc <- buildMCMC(baseTimeConf)
# Compile
#use this one with run alone
#cmcmc <- compileNimble(baseTimeModel,Rmcmc,
#project = cbaseTimeModel,
#                    resetFunctions = TRUE
#                      )
#cmcmc$Rmcmc$run(10000)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
# Run the MCMC
mcmc.out <- runMCMC(cmcmc,
niter = 10000,
nchains =3,
nburnin = 5000,
#inits = initsList,
#thin = 5,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
# baseAuxF <- buildAuxiliaryFilter(baseTimeModel, "x",
# control = list(thresh = 0.5, saveAll = TRUE))
# # Compile filter
# cbaseAuxF <- compileNimble(baseAuxF,project = baseTimeModel)
# # Run auxiliary filter, which returns estimate of model log-likelihood
# auxLLEst <- cbaseAuxF$run(parNum)
# # The auxiliary filter can also return an estimate of the effective
# # sample size (ESS) at each ti
#
#
# baseAuxWts <- as.matrix(cbaseAuxF$mvWSamples, "wts")
# baseAuxUnwtdX <- as.matrix(cbaseAuxF$mvWSamples, "x")
# baseAuxWtdX <- as.matrix(cbaseAuxF$mvEWSamples, "x")
#library('coda')
#par(mfrow = c(2,2))
#posteriorSamps <- as.mcmc(as.matrix(cmcmc$Rmcmc$mvSamples))
#traceplot(posteriorSamps[,'a'], ylab = 'a')
#traceplot(posteriorSamps[,'b'], ylab = 'b')
#traceplot(posteriorSamps[,'c'], ylab = 'c')
#traceplot(posteriorSamps[,'mu_0'], ylab = 'mu_0')
mcmc.out$summary$all.chains
mcmclist <- ggs(mcmc.out$samples)
ggs_density(mcmclist, family = "a")
ggs_density(mcmclist, family = "b")
ggs_density(mcmclist, family = "c")
ggs_density(mcmclist, family = "mu_0")
ggs_traceplot(mcmclist, family = "a")
ggs_traceplot(mcmclist, family = "b")
ggs_traceplot(mcmclist, family = "c")
ggs_traceplot(mcmclist, family = "mu_0")
# simulate some data
t <- 50; mu_0 <- 1
x <- rnorm(1 ,mu_0, 1)
y <- rnorm(1, x, 1)
a <- 0.5; b <- 1; c <- 1
for(i in 2:t){
x[i] <- rnorm(1, x[i-1] * a + b,1)
y[i] <- rnorm(1, x[i] * c, 1)
}
#Set the number of iteration
parNum <- 5000
baseModelCode <- nimbleCode({
x[1] ~ dnorm(mu_0, 1)
y[1] ~ dnorm(x[1], 1)
for(i in 2:t){
x[i] ~ dnorm(x[i-1] * a + b, 1)
y[i] ~ dnorm(x[i] * c, 1)
}
a ~ dunif(0, 1)
b ~ dnorm(0, 1)
c ~ dnorm(1,1)
mu_0 ~ dnorm(0, 1)
})
baseTimeModel <- nimbleModel(baseModelCode, constants = list(t = t),
data <- list(y = y), check = FALSE )
# Set parameter values and compile the model
#baseTimeModel$a <- 0.5
#baseTimeModel$b <- 1
#baseTimeModel$c <- 1
#baseTimeModel$mu_0 <- 1
cbaseTimeModel <- compileNimble(baseTimeModel)
baseTimeConf <- configureMCMC(baseTimeModel) # default MCMC configuration
# Add random walk PMCMC sampler with particle number optimization.
library(nimbleSMC)
baseTimeConf$addSampler(target = c("a", "b", "c", "mu_0"), type = "RW_PF_block",
control = list(propCov= diag(4), adaptScaleOnly = FALSE,
latents = "x", pfOptimizeNparticles = TRUE, filterType = "auxilliary"))
# Build auxiliary filter
Rmcmc <- buildMCMC(baseTimeConf)
# Compile
#use this one with run alone
#cmcmc <- compileNimble(baseTimeModel,Rmcmc,
#project = cbaseTimeModel,
#                    resetFunctions = TRUE
#                      )
#cmcmc$Rmcmc$run(10000)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
# Run the MCMC
mcmc.out <- runMCMC(cmcmc,
niter = 10000,
nchains =3,
nburnin = 5000,
#inits = initsList,
#thin = 5,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
# baseAuxF <- buildAuxiliaryFilter(baseTimeModel, "x",
# control = list(thresh = 0.5, saveAll = TRUE))
# # Compile filter
# cbaseAuxF <- compileNimble(baseAuxF,project = baseTimeModel)
# # Run auxiliary filter, which returns estimate of model log-likelihood
# auxLLEst <- cbaseAuxF$run(parNum)
# # The auxiliary filter can also return an estimate of the effective
# # sample size (ESS) at each ti
#
#
# baseAuxWts <- as.matrix(cbaseAuxF$mvWSamples, "wts")
# baseAuxUnwtdX <- as.matrix(cbaseAuxF$mvWSamples, "x")
# baseAuxWtdX <- as.matrix(cbaseAuxF$mvEWSamples, "x")
#library('coda')
#par(mfrow = c(2,2))
#posteriorSamps <- as.mcmc(as.matrix(cmcmc$Rmcmc$mvSamples))
#traceplot(posteriorSamps[,'a'], ylab = 'a')
#traceplot(posteriorSamps[,'b'], ylab = 'b')
#traceplot(posteriorSamps[,'c'], ylab = 'c')
#traceplot(posteriorSamps[,'mu_0'], ylab = 'mu_0')
mcmc.out$summary$all.chains
mcmclist <- ggs(mcmc.out$samples)
ggs_density(mcmclist, family = "a")
ggs_density(mcmclist, family = "b")
ggs_density(mcmclist, family = "c")
ggs_density(mcmclist, family = "mu_0")
ggs_traceplot(mcmclist, family = "a")
ggs_traceplot(mcmclist, family = "b")
ggs_traceplot(mcmclist, family = "c")
ggs_traceplot(mcmclist, family = "mu_0")
baseModelCode <- nimbleCode({
x[1] ~ dnorm(mu_0, 1)
y[1] ~ dnorm(x[1], 1)
for(i in 2:t){
x[i] ~ dnorm(x[i-1] * a + b, 1)
y[i] ~ dnorm(x[i] * c, 1)
}
a ~ dunif(0, 1)
b ~ dnorm(0, 1)
c ~ dnorm(1,1)
mu_0 ~ dnorm(0, 1)
})
baseTimeModel <- nimbleModel(baseModelCode, constants = list(t = t),
data <- list(y = y), check = FALSE )
# Set parameter values and compile the model
baseTimeModel$a <- 0.5
baseTimeModel$b <- 1
baseTimeModel$c <- 1
baseTimeModel$mu_0 <- 1
cbaseTimeModel <- compileNimble(baseTimeModel)
baseTimeConf <- configureMCMC(baseTimeModel) # default MCMC configuration
# Add random walk PMCMC sampler with particle number optimization.
library(nimbleSMC)
baseTimeConf$addSampler(target = c("a", "b", "c", "mu_0"), type = "RW_PF_block",
control = list(propCov= diag(4), adaptScaleOnly = FALSE,
latents = "x", pfOptimizeNparticles = TRUE, filterType = "auxilliary"))
# Build auxiliary filter
Rmcmc <- buildMCMC(baseTimeConf)
# Compile
#use this one with run alone
#cmcmc <- compileNimble(baseTimeModel,Rmcmc,
#project = cbaseTimeModel,
#                    resetFunctions = TRUE
#                      )
#cmcmc$Rmcmc$run(10000)
#use this with runMCMC
cmcmc <- compileNimble(Rmcmc,
project = cbaseTimeModel,
resetFunctions = TRUE)
# Run the MCMC
mcmc.out <- runMCMC(cmcmc,
niter = 10000,
nchains =3,
nburnin = 5000,
#inits = initsList,
#thin = 5,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
# baseAuxF <- buildAuxiliaryFilter(baseTimeModel, "x",
# control = list(thresh = 0.5, saveAll = TRUE))
# # Compile filter
# cbaseAuxF <- compileNimble(baseAuxF,project = baseTimeModel)
# # Run auxiliary filter, which returns estimate of model log-likelihood
# auxLLEst <- cbaseAuxF$run(parNum)
# # The auxiliary filter can also return an estimate of the effective
# # sample size (ESS) at each ti
#
#
# baseAuxWts <- as.matrix(cbaseAuxF$mvWSamples, "wts")
# baseAuxUnwtdX <- as.matrix(cbaseAuxF$mvWSamples, "x")
# baseAuxWtdX <- as.matrix(cbaseAuxF$mvEWSamples, "x")
#library('coda')
#par(mfrow = c(2,2))
#posteriorSamps <- as.mcmc(as.matrix(cmcmc$Rmcmc$mvSamples))
#traceplot(posteriorSamps[,'a'], ylab = 'a')
#traceplot(posteriorSamps[,'b'], ylab = 'b')
#traceplot(posteriorSamps[,'c'], ylab = 'c')
#traceplot(posteriorSamps[,'mu_0'], ylab = 'mu_0')
mcmc.out$summary$all.chains
mcmclist <- ggs(mcmc.out$samples)
ggs_density(mcmclist, family = "a")
ggs_density(mcmclist, family = "b")
ggs_density(mcmclist, family = "c")
ggs_density(mcmclist, family = "mu_0")
ggs_traceplot(mcmclist, family = "a")
ggs_traceplot(mcmclist, family = "b")
ggs_traceplot(mcmclist, family = "c")
ggs_traceplot(mcmclist, family = "mu_0")
mcmc.out$summary$all.chains
cmcmc
suppressMessages(library(nimble))
suppressMessages(library(myphdthesis)) #install_github("Peprah94/myphdthesis") to install this package
library(kableExtra)
library(ggplot2)
library(ggmcmc)
#library(nimbleSMC)
set.seed(1994)
exampleCode <- nimbleCode({
x0 ~ dnorm(0, var = 1)
x[1] ~ dnorm(.8 * x0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:N){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
N = 50
x0 <- 0
xObs <- yObs <- numeric(N)
xObs[1] <- rnorm(1, .8*x0, sd = 1)
yObs[1] <- rnorm(1, xObs[1], sd = sqrt(0.5))
for(t in 2: N){
xObs[t] <- rnorm(1, 0.8 * xObs[t-1], sd = 1)
yObs[t] <- rnorm(1,xObs[t], sd = sqrt(0.5) )
}
model <- nimbleModel(code = exampleCode, data = list(y = yObs), constants = list(N=N),
inits = list(x0 = 0, x = xObs))
baselineModel <- buildAuxiliaryFilter(model, 'x',
control = list(saveAll = TRUE, lookahead = "mean", smoothing = FALSE))
Cmodel <- compileNimble(model)
cbaselineModel <- compileNimble(baselineModel, project = model)
logLik <- cbaselineModel$run(m = 10000)
ESS <- cbaselineModel$returnESS()
auxWts <- as.matrix(cbaselineModel$mvWSamples, "wts")
baselineWeights <- as.matrix(cbaselineModel$mvWSamples, "wts")
baselineUnweightedSamples <- as.matrix(cbaselineModel$mvWSamples, "x")
baselineWeightedSamples <- as.matrix(cbaselineModel$mvEWSamples, "x")
plotDataBaseline <- data.frame(t = seq(1,N, 1),
true = xObs,
unwtsXbaseline = apply(baselineUnweightedSamples,2,median),
wtsXBaseline = colMeans(baselineWeightedSamples)
#unwtsX = baselineUnweightedSamples[1,],
#wtsX = baselineWeightedSamples[1,]
)
model <- nimbleModel(code = exampleCode, data = list(y = yObs), constants = list(N=N),
inits = list(x0 = 0, x = xObs))
baselineModel <- buildAuxiliaryFilter(model, 'x',
control = list(saveAll = TRUE, lookahead = "mean", smoothing = FALSE))
Cmodel <- compileNimble(model)
cbaselineModel <- compileNimble(baselineModel, project = model)
logLik <- cbaselineModel$run(m = 10000)
ESS <- cbaselineModel$returnESS()
auxWts <- as.matrix(cbaselineModel$mvWSamples, "wts")
baselineWeights <- as.matrix(cbaselineModel$mvWSamples, "wts")
baselineUnweightedSamples <- as.matrix(cbaselineModel$mvWSamples, "x")
baselineWeightedSamples <- as.matrix(cbaselineModel$mvEWSamples, "x")
plotDataBaseline <- data.frame(t = seq(1,N, 1),
true = xObs,
unwtsXbaseline = apply(baselineUnweightedSamples,2,median),
wtsXBaseline = colMeans(baselineWeightedSamples)
#unwtsX = baselineUnweightedSamples[1,],
#wtsX = baselineWeightedSamples[1,]
)
#| label: table_baseline
#| fig-cap: The weighted and unweighted samples from the particle Filter
#| warning: false
#| message: false
#|
head(plotDataBaseline)%>%
kbl() %>%
kable_material(c("striped", "hover"))
plotDataBaseline%>%
reshape2::melt(., id.vars = "t")%>%
ggplot()+
geom_line(mapping = aes(x = t, y = value, linetype = variable, col = variable ))
reducedModel <- model$newModel(replicate = TRUE)
#set the years without data as NA
reducedModel$y[41:50] <- NA
reducedModel$x[41:50] <- NA
compileNimble(reducedModel)
reducedAuxModel <- buildAuxiliaryFilter(reducedModel, 'x',
control = list(saveAll = TRUE, lookahead = "mean", smoothing = FALSE))
cReducedModel <- compileNimble(reducedAuxModel, project = reducedModel)
logLik <- cReducedModel$run(m = 10000)
ESS <- cReducedModel$returnESS()
auxWts <- as.matrix(cReducedModel$mvWSamples, "wts")
reducedWeights <- as.matrix(cReducedModel$mvWSamples, "wts")
reducedUnweightedSamples <- as.matrix(cReducedModel$mvWSamples, "x")
reducedWeightedSamples <- as.matrix(cReducedModel$mvEWSamples, "x")
plotDataReduced <- data.frame(t = seq(1,N, 1),
true = xObs,
unwtsXReduced = apply(reducedUnweightedSamples,2,median),
wtsXReduced = colMeans(reducedWeightedSamples)
#unwtsX = baselineUnweightedSamples[1,],
#wtsX = baselineWeightedSamples[1,]
)
#| label: table_reduced
#| fig-cap: The weighted and unweighted samples from the particle Filter
#| warning: false
#| message: false
#|
head(plotDataReduced)%>%
kbl() %>%
kable_material(c("striped", "hover"))
plotDataReduced%>%
reshape2::melt(., id.vars = "t")%>%
ggplot()+
geom_line(mapping = aes(x = t, y = value, linetype = variable, col = variable ))
updatedModel <- model$newModel(replicate = TRUE)
#set the years without data as NA
updatedModel$x[41:50] <- NA
compileNimble(updatedModel)
updatedAuxModel <- buildAuxiliaryFilterUpdate(updatedModel, 'x',reducedWeights,
reducedUnweightedSamples,reducedWeightedSamples,
control = list(saveAll = TRUE, lookahead = "mean", smoothing = FALSE,  M = 10, iNodePrev = 40))
cUpdatedModel <- compileNimble(updatedAuxModel, project = updatedModel)
logLik <- cUpdatedModel$run(m = 10000)
ESS <- cUpdatedModel$returnESS()
auxWts <- as.matrix(cUpdatedModel$mvWSamples, "wts")
updatedWeights <- as.matrix(cUpdatedModel$mvWSamples, "wts")
updatedUnweightedSamples <- as.matrix(cUpdatedModel$mvWSamples, "x")
updatedWeightedSamples <- as.matrix(cUpdatedModel$mvEWSamples, "x")
plotDataUpdated <- data.frame(t = seq(1,N, 1),
true = xObs,
unwtsXUpdated = apply(updatedUnweightedSamples,2,median),
wtsXUpdated = colMeans(updatedWeightedSamples)
#unwtsX = baselineUnweightedSamples[1,],
#wtsX = baselineWeightedSamples[1,]
)
#| label: table_updated
#| fig-cap: The weighted and unweighted samples from the particle Filter
#| warning: false
#| message: false
#|
head(plotDataUpdated)%>%
kbl() %>%
kable_material(c("striped", "hover"))
dfDataBaseline <- plotDataBaseline%>%
reshape2::melt(., id.vars = "t")
dfDataReduced <- plotDataReduced%>%
reshape2::melt(., id.vars = "t")
dfDataUpdated <- plotDataUpdated%>%
reshape2::melt(., id.vars = "t")
plotData <- rbind(dfDataBaseline,
dfDataReduced ,
dfDataUpdated)
plotData%>%
ggplot()+
geom_line(mapping = aes(x = t, y = value, linetype = variable, col = variable))+
ylab("Latent samples from PFs")+
theme_classic()
