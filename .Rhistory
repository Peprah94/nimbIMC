n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
mcmc = TRUE
nParFiltRun = NULL
MCMCconfiguration = NULL
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
smoothing = pfControl[["smoothing"]]
pfControl = list(saveAll = TRUE,
#lookahead = "mean",
smoothing = FALSE)
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
smoothing = pfControl[["smoothing"]]
latent
#
cMCMC <- configureMCMC(model, monitors = c(target, latent))
#
bMCMC <- buildMCMC(cMCMC)
#
coMCMC <- compileNimble(bMCMC, project = nMCompile)
nMCompile <- compileNimble(model)
#
cMCMC <- configureMCMC(model, monitors = c(target, latent))
#
bMCMC <- buildMCMC(cMCMC)
#
coMCMC <- compileNimble(bMCMC, project = nMCompile)
#
timeStart2 <- Sys.time()
mcmc.out <- runMCMC(coMCMC,
niter = n.iter,
nchains = n.chains,
nburnin = n.burnin,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
n.chains
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
smoothing = pfControl[["smoothing"]]
#
timeStart2 <- Sys.time()
mcmc.out <- runMCMC(coMCMC,
niter = n.iter,
nchains = n.chains,
nburnin = n.burnin,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
# Setting up MCMC configuration values and variation of parameters
nIterations = 50
nBurnin = 10
nChains = 2
nThin = 1
nyears = 50
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
n.thin = MCMCconfiguration[["n.thin"]]
smoothing = pfControl[["smoothing"]]
nMCompile <- compileNimble(model)
#
cMCMC <- configureMCMC(model, monitors = c(target, latent))
#
bMCMC <- buildMCMC(cMCMC)
#
coMCMC <- compileNimble(bMCMC, project = nMCompile)
#
timeStart2 <- Sys.time()
mcmc.out <- runMCMC(coMCMC,
niter = n.iter,
nchains = n.chains,
nburnin = n.burnin,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
coMCMC$mvSamples
nLatent <- model$expandNodeNames("x")
nLatent
latentNodes <- model$expandNodeNames("x")
m <- n.iter - n.burnin
weights <- matrix(1, nrow = m, ncol = length(latentNodes))
unweightedSamples <- mcmc.out$samples$chain1
unweightedSamples
unweightedSamples <- mcmc.out$samples$chain1[, latentNodes]
unweightedSamples
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
for(j in 1:length(latentNodes)){
logLike[i,j] <- model$calculate(latentNodes[j])
}
logLike
model$calculate("x")
model$a
model$varNames
model$getNodeNames(stochOnly = TRUE)
model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
size <- length(latentNodes)
message("Saving unsampled and sampled values in model values for updating")
names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
size <- length(latentNodes)
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = namesEWS,
types = type,
sizes = size))
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
message("Saving unsampled and sampled values in model values for updating")
names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
size <- length(names)
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
names
size
mvSamplesEst <- modelValues(modelValuesConf(vars = "mcmcStored",
types = type,
sizes = size))
mvSamplesEst
resize(mvSamplesEst, m)
mvSamplesEst
for(i in 1: m){
mvSamplesEst[["mcmcStored"]][[i]] <- mcmc.out$samples$chain1[i, names]
}
mvSamplesEst
i = 1
mvSamplesEst[["mcmcStored"]][[i]]
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = model, row = i, rowTo = i)
logLike[i,j] <- model$calculate(latentNodes[j])
}
estimationModel <- model$newModel(replicate = TRUE)
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, row = i, rowTo = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names, nodesTo = names,row = i, rowTo = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
names
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i, logProb = TRUE)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i, logProb = TRUE)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = 1, logProb = TRUE)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
for(i in 1:m){
#for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = 1, logProb = TRUE)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
# }
}
for(i in 1:m){
#for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = 1)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
# }
}
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
#for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
# }
}
mvSamplesEst[["mcmcStored"]][[i]]
names
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
#for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
# }
}
mvSamplesEst
class(mvSamplesEst)
for(i in 1: m){
mvSamplesEst[["x"]][[i]] <- mcmc.out$samples$chain1[i, latentNodes]
}
#names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names(latentNodes)
size <- length(names)
#names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- latentNodes
size <- length(names)
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
resize(mvSamplesEst, m)
#names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- latent
size <- length(names)
#names <- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- latent
size <- length(latentNodes)
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
resize(mvSamplesEst, m)
for(i in 1: m){
mvSamplesEst[["x"]][[i]] <- mcmc.out$samples$chain1[i, latentNodes]
}
mvSamplesEst[["x"]][[i]]
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
#for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i)
#logLike[i,j] <- estimationModel$calculate(latentNodes[j])
# }
}
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
message("Saving unsampled and sampled values in model values for updating")
estimationModel$calculate(latentNodes[1])
latentNodes[1]
estimationModel$calculate("x[1]")
estimationModel$calculate("x")
estimationModel$mu0
estimationModel$a
estimationModel$b
model = newModelReduced
estimationModel <- model$newModel(replicate = TRUE)
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = names,row = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
logLike
latentNodes
latent
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = latentNodes,row = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
logLike
latentNodes
namesEst<- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- latent
size <- length(namesEst)
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
resize(mvSamplesEst, m)
for(i in 1: m){
mvSamplesEst[["x"]][[i]] <- mcmc.out$samples$chain1[i, namesEst]
}
mvSamplesEst[["x"]][[i]]
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1:m){
for(j in 1:length(latentNodes)){
nimCopy(from = mvSamplesEst, to = estimationModel, nodes = namesEst,row = i)
logLike[i,j] <- estimationModel$calculate(latentNodes[j])
}
latent
names <- c(latent, target)
names
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
message("Saving unsampled and sampled values in model values for updating")
namesEst<- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- c(latent, target)
size <- c(length(latentNodes), 1,1,1,1)
type <- rep("double", 5)
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
message("Saving unsampled and sampled values in model values for updating")
namesEst<- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- c(target)
size <- c(length(target))
type <- c("double")
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
mvSamplesEst <- list()
for(i in 1:length(names)){
mvSamplesEst[[i]] <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
}
message("Saving unsampled and sampled values in model values for updating")
namesEst<- model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
names <- c(target)
size <- 1
type <- c("double")
mvSamplesEst <- list()
for(i in 1:length(names)){
mvSamplesEst[[i]] <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
}
for(i in 1:length(names)){
mvSamplesEst[[i]] <- modelValues(modelValuesConf(vars = names[i],
types = type,
sizes = size))
}
mvSamplesEst
lappy(mvSamplesEst, function(x) {resize(mvSamplesEst, m)})
lapply(mvSamplesEst, function(x) {resize(mvSamplesEst, m)})
resize(mvSamplesEst[[1]], m)
for(i in 1:length(names)){
mvSamplesEst[[i]] <- modelValues(modelValuesConf(vars = names[i],
types = type,
sizes = size))
resize(mvSamplesEst[[i]], m)
}
mvSamplesEst <- list()
for(j in 1:length(names)){
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
for(i in 1: m){
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, names[j]]
}
for(j in 1:length(names)){
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
for(i in 1: m){
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, names[j]]
}
nimCopy(from = mvSamplesEst[[j]], to = estimationModel, nodes = names[j],row = i)
}
latentNodes
mvSamplesEst <- list()
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1: m){
for(j in 1:length(names)){
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, names[j]]
nimCopy(from = mvSamplesEst[[j]], to = estimationModel, nodes = names[j],row = i)
}
for(k in 1:length(latentNodes)){
logLike[i,k] <- estimationModel$calculate(latentNodes[k])
}
logLike
k = 1
estimationModel$calculate(latentNodes[k])
k = 2
estimationModel$calculate(latentNodes[k])
model$getClass
model$getClass()
model$a
model$expandNodeNames("a")
names <- c(target, latent)
type <- c("double")
mvSamplesEst <- list()
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1: m){
for(j in 1:length(names)){
size <- length(model$expandNodeNames(names[j]))
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, names[j]]
nimCopy(from = mvSamplesEst[[j]], to = estimationModel, nodes = names[j],row = i)
}
for(k in 1:length(latentNodes)){
logLike[i,k] <- estimationModel$calculate(latentNodes[k])
}
mvSamplesEst <- list()
logLike <- matrix(NA, nrow = m, ncol = length(latentNodes))
for(i in 1: m){
for(j in 1:length(names)){
size <- length(model$expandNodeNames(names[j]))
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, model$expandNodeNames(names[j])]
nimCopy(from = mvSamplesEst[[j]], to = estimationModel, nodes = names[j],row = i)
}
for(k in 1:length(latentNodes)){
logLike[i,k] <- estimationModel$calculate(latentNodes[k])
}
logLike
k
estimationModel$calculate(latentNodes[k])
estimationModel
estimationModel$a
estimationModel$b
estimationModel$c
estimationModel$y
estimationModel$x
estimationModel$calculate("x[1]")
estimationModel$calculate("x[10]")
estimationModel$calculate("x[2]")
estimationModel$calculate("x[1]")
j  = 5
i = 1
size <- length(model$expandNodeNames(names[j]))
size
mvSamplesEst[[j]] <- modelValues(modelValuesConf(vars = names[j],
types = type,
sizes = size))
resize(mvSamplesEst[[j]], m)
mvSamplesEst[[j]][[names[j]]][[i]] <- mcmc.out$samples$chain1[i, model$expandNodeNames(names[j])]
mvSamplesEst[[j]]
mvEWS <- mvWS <- mvSamplesEst[[length(names)]]
devtools::load_all(".")
message(paste("Running reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
message(paste("Reduced model configuration for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
data <- list(
#y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
y = simData$y[-c((iNodePrev[iNodetag]+1):50)]
)
constants <- list(
t = iNodePrev[iNodetag]
)
newModelReduced <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
check = FALSE)
message(paste("Fitting reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
example1ReducedModel <- spartaNimWeights(model = newModelReduced, latent = "x", mcmc = TRUE,
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
)
devtools::load_all(".")
example1ReducedModel <- spartaNimWeights(model = newModelReduced, latent = "x", mcmc = TRUE,
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin)
)
devtools::load_all(".")
#
# ## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
check = FALSE)
message("Running baseline model (particle MCMC from nimbleSMC) for a = ", aVars[aVarstag])
#Define a new model
newModel <- stateSpaceModel$newModel(replicate = TRUE)
# Function to run the baseline model
baselineModel <- myphdthesis::baselineSpartaEstimation(model = newModel, latent = "x",
MCMCconfiguration = list(target = c('a', 'b', 'c', 'mu0'),
additionalPars = "x",
n.iter = nIterations,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin))
message(paste("Running reduced model for iNodePrev = ", iNodePrev[iNodetag], "and a = ", aVars[aVarstag]))
