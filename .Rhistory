smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
devtools::load_all(".")
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
devtools::load_all(".")
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
latentNodes <- model$expandNodeNames(latent)
nodes <- findLatentNodes(model, latent, timeIndex)
dims <- lapply(nodes, function(n) nimDim(model[[n]]))
if(length(unique(dims)) > 1)
stop('sizes or dimensions of latent states varies')
vars <- model$getVarNames(nodes =  nodes)
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
#expand target names
targetAsScaler <- model$expandNodeNames(target)
names <- c(names, targetAsScaler)
type <- c(type, rep("double", length(targetAsScaler)))
#create additional sizes for the target vars
addSize <- list()
for(i in 1:length(targetAsScaler)){
addSize[[i]] <- length(dims)
#names(size)[i + 1] <- target[i]
}
names(addSize) <- targetAsScaler
#include them in the sizes
size <- c(size, addSize)
mvSamplesEst <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
mvSamplesEst
reducedModel$mvSamples
resize(mvSamplesEst, n.iter)
mvSamplesEst
mvSamplesEst[["z"]]
m
n.iter
model$expandNodeNames(names[j])
mvSamplesEst[[names[j]]][[iter]]
j
size
size[[1]]
for(iter in 1:n.iter){
#for(i in 1: m){
for(j in 1:length(names)){
if(names[j] == latent){
mvSamplesEst[[names[j]]][[iter]] <- matrix(mcmcOut[iter, model$expandNodeNames(names[j])], nrow = size[[1]][1], ncol = size[[1]][2])
}else{
mvSamplesEst[[names[j]]][[iter]] <-  mcmcOut[iter, model$expandNodeNames(names[j])]
}
#nimCopy(from = mvSamplesEst, to = model, nodes = names[j],row = i)
#}
}
# for(k in 1:length(latentNodes)){
#   logLike[,k] <- 0
# }
}
mvSamplesEst[[names[j]]][[iter]]
j = 1
iter = 1
mvSamplesEst[[names[j]]][[iter]]
devtools::load_all(".")
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
m = n.iter
#control list extraction
thresh <- control[['thresh']]
saveAll <- control[['saveAll']]
smoothing <- control[['smoothing']]
silent <- control[['silent']]
timeIndex <- control[['timeIndex']]
initModel <- control[['initModel']]
iNodePrev <- control[['iNodePrev']]
#initModel <- control[['initModel']]
M <- control[['M']]
resamplingMethod <- control[['resamplingMethod']]
if(is.null(thresh)) thresh <- .8
if(is.null(silent)) silent <- TRUE
if(is.null(saveAll)) saveAll <- FALSE
if(is.null(smoothing)) smoothing <- FALSE
if(is.null(initModel)) initModel <- TRUE
if(is.null(resamplingMethod)) resamplingMethod <- 'default'
if(!(resamplingMethod %in% c('default', 'multinomial', 'systematic', 'stratified',
'residual')))
stop('buildBootstrapFilter: "resamplingMethod" must be one of: "default", "multinomial", "systematic", "stratified", or "residual". ')
## latent state info
targetNodesAsScalar <- model$expandNodeNames(target, returnScalarComponents = TRUE)
#storeModelValues <- values(model, targetNodesAsScalar)
nodes <- findLatentNodes(model, nodes, timeIndex)
dims <- lapply(nodes, function(n) nimDim(model[[n]]))
if(length(unique(dims)) > 1)
stop('buildBootstrapFilter: sizes or dimensions of latent states varies.')
vars <- model$getVarNames(nodes =  nodes)
my_initializeModel <- initializeModel(model, silent = silent)
if(0 > thresh || 1 < thresh || !is.numeric(thresh))
stop('buildBootstrapFilter: "thresh" must be between 0 and 1.')
if(!saveAll & smoothing)
stop("buildBootstrapFilter: must have 'saveAll = TRUE' for smoothing to work.")
## Create mv variables for x state and sampled x states.  If saveAll=TRUE,
## the sampled x states will be recorded at each time point.
modelSymbolObjects <- model$getSymbolTable()$getSymbolObjects()[vars]
names <- sapply(modelSymbolObjects, function(x)return(x$name))
type <- sapply(modelSymbolObjects, function(x)return(x$type))
size <- lapply(modelSymbolObjects, function(x)return(x$size))
mvEWSamples <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
latent <- names
names <- c(names, "wts", "bootLL")
type <- c(type, "double", "double")
size$wts <- length(dims)
size$bootLL <- length(dims)
size$wts <- 1
size$wts <- length(dims)
size$bootLL <- length(dims)
mvWSamples  <- modelValues(modelValuesConf(vars = names,
types = type,
sizes = size))
resize(mvWSamples, m)
resize(mvEWSamples, m)
mvWSamples
mvWSamples[["z"]]
target
iterRun
iterRun = 1
nimCopy(from = mvSamplesEst, to = model, nodes = target,row = iterRun)
#if(iNode == iNodePrev){
#modelSteps <- particleFilter_splitModelSteps(model, nodes, iNode, notFirst)
#prevDeterm <- modelSteps$prevDeterm
#prevDeterm <- model$getDependencies(prevNodeUpdates, determOnly = TRUE)
#calc_thisNode_self <- modelSteps$calc_thisNode_self
#calc_thisNode_deps <- modelSteps$calc_thisNode_deps
#prevDeterm <- prevDeterm[!prevDeterm %in%calc_thisNode_deps]
#}else{
modelSteps <- particleFilter_splitModelSteps(model, nodes, iNode, notFirst)
prevDeterm <- modelSteps$prevDeterm
calc_thisNode_self <- modelSteps$calc_thisNode_self
calc_thisNode_deps <- modelSteps$calc_thisNode_deps
# }
targetNodesAsScalar <- model$expandNodeNames(target, returnScalarComponents = TRUE)
prevNode <- nodes[if(notFirst) iNode-1 else iNode]
thisNode <- nodes[iNode]
#nTarget <- length(target)
## t is the current time point.
t <- iNode
## Get names of xs node for current and previous time point (used in copy)
if(saveAll == 1){
allPrevNodes <- model$expandNodeNames(nodes[1:(iNode-1)])
prevXName <- prevNode
thisXName <- thisNode
currInd <- t
prevInd <- t-1
if(isTRUE(smoothing)){
currInd <- 1
prevInd <- 1
}
} else {
allPrevNodes <- names
prevXName <- names
thisXName <- names
currInd <- 1
prevInd <- 1
}
isLast <- (iNode == length(nodes))
ess <- 0
resamplerFunctionList <- nimbleFunctionList(resamplerVirtual)
if(resamplingMethod == 'default'){
resamplerFunctionList[[1]] <- residualResampleFunction()
defaultResamplerFlag <- TRUE
}
if(resamplingMethod == 'residual')
resamplerFunctionList[[1]] <- residualResampleFunction()
if(resamplingMethod == 'multinomial')
resamplerFunctionList[[1]] <- multinomialResampleFunction()
if(resamplingMethod == 'stratified')
resamplerFunctionList[[1]] <- stratifiedResampleFunction()
if(resamplingMethod == 'systematic')
resamplerFunctionList[[1]] <- systematicResampleFunction()
i = 1
#copy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
#copy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
copy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
#copy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
#copy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
nimCopy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
mvWSamples[["z"]][[1]]
i
thisNode
devtools::load_all(".")
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
values(model, targetNodesAsScalar)
targetNodesAsScalar
values(model, "theta")
values(model, occupancyCoefs[1])
values(model, "occupancyCoefs[1]")
model$getVarNames()
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
#copy(from = mvSamplesEst, to = model, nodes = target,row = iterRun, rowTo = 1)
#if(notFirst) {
# model$calculate(prevDeterm)
#}
for(i in 1:m) {
#if(notFirst) {
#  if(smoothing == 1){
#    copy(mvEWSamples, mvWSamples, nodes = allPrevNodes,
#        nodesTo = allPrevNodes, row = iterRun, rowTo=i)
# }
#copy(mvEWSamples, model, nodes = prevXName, nodesTo = prevNode, row = i)
#model$calculate(prevDeterm)
#}
#copy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
#copy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
nimCopy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
copy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
#if(t == 1){
#  storeModelValues <<- values(model, targetNodesAsScalar)
#}
#for(k in 1:nTarget){
nimCopy(from = mvSamplesEst, to = model, nodes = target,row = iterRun)
if(notFirst) {
model$calculate(prevDeterm)
}
# model$calculate(prevDeterm)
#}
#mvWSamples[latent,i][currInd] <<- mvWSamplesXSaved[i, currInd]
#mvEWSamples[latent,i][currInd] <<- mvEWSamplesXSaved[i, currInd]
mvWSamples['wts',i][currInd] <<- 1#mvWSamplesWTSaved[i, currInd]
mvWSamples['bootLL',i][currInd] <<-0 #logLikeVals[1, currInd]
wts[i] <- 1#mvWSamplesWTSaved[i, currInd]
}
#copy(from = mvSamplesEst, to = model, nodes = target,row = iterRun, rowTo = 1)
#if(notFirst) {
# model$calculate(prevDeterm)
#}
for(i in 1:m) {
#if(notFirst) {
#  if(smoothing == 1){
#    copy(mvEWSamples, mvWSamples, nodes = allPrevNodes,
#        nodesTo = allPrevNodes, row = iterRun, rowTo=i)
# }
#copy(mvEWSamples, model, nodes = prevXName, nodesTo = prevNode, row = i)
#model$calculate(prevDeterm)
#}
#copy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
#copy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = i)
nimCopy(mvSamplesEst, mvWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
nimCopy(mvSamplesEst, mvEWSamples, nodes = thisNode, nodesTo = thisXName, row = iterRun, rowTo = i)
#if(t == 1){
#  storeModelValues <<- values(model, targetNodesAsScalar)
#}
#for(k in 1:nTarget){
nimCopy(from = mvSamplesEst, to = model, nodes = target,row = iterRun)
if(notFirst) {
model$calculate(prevDeterm)
}
# model$calculate(prevDeterm)
#}
#mvWSamples[latent,i][currInd] <<- mvWSamplesXSaved[i, currInd]
#mvEWSamples[latent,i][currInd] <<- mvEWSamplesXSaved[i, currInd]
mvWSamples['wts',i][currInd] <<- 1#mvWSamplesWTSaved[i, currInd]
mvWSamples['bootLL',i][currInd] <<-0 #logLikeVals[1, currInd]
wts[i] <- 1#mvWSamplesWTSaved[i, currInd]
}
#if(t == 1){
#  storeModelValues <<- values(model, targetNodesAsScalar)
#}
#for(k in 1:nTarget){
nimCopy(from = mvSamplesEst, to = model, nodes = target,row = iterRun)
if(notFirst) {
model$calculate(prevDeterm)
}
devtools::load_all(".")
updatedCase2 <- spartaNimUpdates(model = autologisticModel,
reducedModel = newModel,
latent = "z",
pfControl = list(saveAll = TRUE,
smoothing = FALSE,
timeIndex = 2,
mcmc = TRUE,
M = nyear - iNodePrev[iNode.tag],
iNodePrev = iNodePrev[iNode.tag]),
MCMCconfiguration = list(target = c('theta', 'occupancyCoefs', 'detectionCoefs'),
additionalPars = "psi.fs",
n.iter = nIterations - nBurnin,
n.chains = nChains,
n.burnin = nBurnin,
n.thin = nThin),
postReducedMCMC = reducedCase2$mcmcSamplesAndSummary
)
library(myphdthesis)
load("/Volumes/kwakupa/example1ReducedIn145A2.RData")
load("/Volumes/kwakupa/example1SimData12.RData")
load("/Volumes/kwakupa/example1UpdatedIn1AUX45A2.RData")
models = list(example1ReducedModel, example1UpdatedModel)
models
x <- model[[1]]
x <- models[[1]]
x
names(x)
length(x$timeRun)
x <- models[[2]]
length(x$timeRun)
nDim <- length(x$timeRun)
if(timeRun) lapply(models, function(x){
nDim <- length(x$timeRun)
if(nDim == 1){
x$timeRun
}else{
x$timeRun$all.chains
}
})
timeRun <- metrics[["timeRun"]]
metrics = list(timeRun = TRUE,
ESS = TRUE,
efficiency = TRUE)
timeRun <- metrics[["timeRun"]]
ESS <- metrics[["ESS"]]
efficiency <- metrics[["efficiency"]]
if(timeRun) lapply(models, function(x){
nDim <- length(x$timeRun)
if(nDim == 1){
x$timeRun
}else{
x$timeRun$all.chains
}
})
if(timeRun) lapply(models, function(x){
nDim <- length(x$timeRun)
if(nDim == 1){
x$timeRun
}else{
x$timeRun$all.chains
}
})%>%
do.call('c', .)
library(dplyr)
if(timeRun) lapply(models, function(x){
nDim <- length(x$timeRun)
if(nDim == 1){
x$timeRun
}else{
x$timeRun$all.chains
}
})%>%
do.call('c', .)
library(ggmcmc)
library(mcmcse)
multiESS(x$samples)
x$samples
x$samples$chain1
multiESS(x$samples$chain1)
x$samples$chain1
multiESS(as.matrix(x$samples$chain1))
as.matrix(x$samples$chain1)
multiESS(as.matrix(x$samples$chain1$samples))
load("/Volumes/kwakupa/example1UpdatedIn1AUX45A2.RData")
load("/Volumes/kwakupa/example1SimData12.RData")
load("/Volumes/kwakupa/example1ReducedIn145A2.RData")
model = list(example1ReducedModel, example1UpdatedModel)
x <- model[[1]]
x
mcmcse::multiESS(as.matrix(x$samples$chain1$samples))
mcmcse::multiESS(as.matrix(x$samples))
x$samples
mcmcse::multiESS(as.matrix(x$samples$chain1))
mcmcse::multiESS(as.matrix(x$samples$chain1),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)
mcmcse::multiESS(as.matrix(x$samples$chain1),method = "obm")
mcmcse::multiESS(as.matrix(x$samples$chain1),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)
as.list(1:2)
c(lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)}))
ret <- lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)
ret
lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)%>%
mean(.)
x <- models[[2]]
lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)
as.matrix(x$samples$chain1[[y]][[1]])
Y = 1
y = 1
as.matrix(x$samples$chain1[[y]][[1]])
x$samples$chain1[[y]][[1]]
x$samples[[y]][[1]]
x$samples[[y]]
x$samples[[y]][[2]]
ret <- lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]][[2]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)%>%
mean(.)
if(ESS) ESSret <- lapply(models, function(x){
nDim <- length(x$timeRun)
if(nDim == 1){
ret <- lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)%>%
mean(.)
}else{
ret <- lapply(as.list(1:2), function(y){mcmcse::multiESS(as.matrix(x$samples[[y]][[2]]),method = "obm", r = 1,
size = NULL, g = NULL, adjust = TRUE,
blather = TRUE)})%>%
do.call('c', .)%>%
mean(.)
}
})
