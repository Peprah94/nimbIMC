exp.z <- z[, t-1]*psi + (1-z[, t-1])*gamma
z[, t] <- rbinom(n = nsites, size = 1, prob = exp.z)
}
#observed data
for(t in 1:nyears){
for(j in 1:nvisits){
y[ ,j,t] <- rbinom(n = nsites, size = 1, prob = z[,t]*p)
}
#Covariates
covs = NULL
}else{
elevation <- rnorm(nsites, 0,1)
springPrecipitation <- matrix(rnorm(nsites*nyears, 0,1), nsites,nyears)
windSpeed <- array(rnorm(nsites*nyears*nvisits), dim = c(nsites, nvisits, nyears))
phi <- plogis(alphaPhi + betaPhi*elevation) #for initial occupancy
psi <- plogis(alphaPsi + betaPsi * springPrecipitation) #for occupancy transitions
p <- plogis(alphaP + betaP * windSpeed) #detection probability
for(i in 1:nsites){
z[i,1] <- rbinom(n = 1, size = 1, prob = phi[i])
#psi.eq <- gamma/ (gamma + (1-phi))
#generate presence/absence (i.e. the truth) in subsequent years
exp.z <- numeric(nsites)
for(t in 2:nyears){
exp.z[i] <- z[i, t-1]*psi[i,t] + (1-z[i, t-1])*gamma
z[i, t] <- rbinom(n = 1, size = 1, prob = exp.z[i])
}
#observed data
for(t in 1:nyears){
for(j in 1:nvisits){
y[i,j,t] <- rbinom(n = 1, size = 1, prob = z[i,t]*p[i, j,t])
}
covs = list(elevation = elevation,
springPrecipitation = springPrecipitation,
windSpeed = windSpeed)
}
# Derived quantities
psi.fs <- numeric(nyears)
for(t in 1:nyears){
psi.fs[t] <- sum(z[,t])/nsites
}
return(list(z = z,
y = y,
psi.fs = psi.fs,
#psi.eq = psi.eq,
covariates = covs,
phi = phi,
psi = psi,
gamma = gamma
))
}
#setParameters
n.years = 25
nReducedYears = 20
n.sites = 30
n.visits = 6
niters = 10
nburnins = 5
nchains = 2
simData <- simDynamicOccupancyData(nsites = n.sites,
nvisits = n.visits,
nyears = n.years,
alphaPhi = 2,
betaPhi = -2,
alphaPsi = -1.5,
betaPsi = 3,
alphaP = 1,
betaP = -1,
gamma = 0.8, covariate = covariateIndex)
simData
#NIMBLE Model
covariate <- covariateIndex
occStateModel <- nimbleCode({
#prior distribution
alphaP ~ dnorm(0, sd = 10)
betaP ~ dnorm(0, sd = 10)
alphaPsi ~ dnorm(0, sd = 10)
betaPsi ~ dnorm(0, sd = 10)
alphaPhi ~ dnorm(0, sd = 10)
betaPhi ~ dnorm(0, sd = 10)
gamma ~ dunif(0,1)
if(!covariate){
logit(psi) <- alphaPsi
logit(phi) <- alphaPhi
logit(p) <- alphaP
for(site.tag in 1:nsites){
z[site.tag,1] ~ dbern(phi)
for(year.tag in 2:nyears){
z[site.tag, year.tag] ~  dbern(z[site.tag, year.tag -1]*(psi - gamma ) + gamma)#+ (1 - z[site.tag, year.tag-1]*gamma))
}
#Observation model
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
for(year.tag in 1:nyears){
y[site.tag, visit.tag, year.tag] ~ dbern(z[site.tag, year.tag]*p)
}
}else{
for(site.tag in 1:nsites){
logit(phi[site.tag]) <- alphaPhi + betaPhi*elevation[site.tag]
for(year.tag in 1:nyears){
logit(psi[site.tag, year.tag]) <- alphaPsi + betaPsi*springPrecipitation[site.tag, year.tag]
for(visit.tag in 1:nvisits){
logit(p[site.tag, visit.tag, year.tag]) <- alphaP + betaP * windSpeed[site.tag, visit.tag, year.tag]
}
for(site.tag in 1:nsites){
z[site.tag,1] ~ dbern(phi[site.tag])
for(year.tag in 2:nyears){
z[site.tag, year.tag] ~  dbern(z[site.tag, (year.tag -1)]*(psi[site.tag, year.tag] -gamma) + gamma)#+ (1 - z[site.tag, (year.tag-1)]*gamma))
}
#Observation model
for(site.tag in 1:nsites){
for(visit.tag in 1:nvisits){
for(year.tag in 1:nyears){
y[site.tag, visit.tag, year.tag] ~ dbern(z[site.tag, year.tag]*p[site.tag, visit.tag, year.tag])
}
# Derived parameters - prop of occuppied sites
for (t in 1:nyears) {
psi.fs[t] <- sum(z[1:nsites, t])/nsites
}
)
if(!covariate){
data <- list(
y = simData$y
)
}else{
data <- list(
y = simData$y,
elevation = simData$covariates$elevation,
springPrecipitation = simData$covariates$springPrecipitation,
windSpeed = simData$covariates$windSpeed
)
}
constants <- list(
nyears = n.years,
nvisits = n.visits,
nsites = n.sites
)
inits <- list(
gamma = 1,
alphaP = 1,
alphaPhi = 1,
alphaPsi = 1,
betaP = 1,
betaPsi = 1,
betaPhi = 1,
z = matrix(1, nrow = constants$nsites, ncol = constants$nyears)
)
occStateSpaceModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
occStateSpaceModel$initializeInfo()
if(!covariate){
targetsToMonitor =  c('alphaPsi', 'alphaPhi',  'alphaP', 'gamma')
}else{
targetsToMonitor =  c('alphaPsi', 'betaPsi', 'alphaPhi', 'betaPhi', 'alphaP', 'betaP', 'gamma')
}
newModel <- occStateSpaceModel$newModel(replicate = TRUE)
if(!covariate){
data <- list(
y = simData$y[,,1:nReducedYears]
)
}else{
data <- list(
y = simData$y[,,1:nReducedYears],
elevation = simData$covariates$elevation,
springPrecipitation = simData$covariates$springPrecipitation,
windSpeed = simData$covariates$windSpeed
)
}
constants <- list(
nyears = nReducedYears,
nvisits = n.visits,
nsites = n.sites
)
inits <- list(
gamma = 1,
alphaP = 1,
alphaPhi = 1,
alphaPsi = 1,
betaP = 1,
betaPsi = 1,
betaPhi = 1,
z = matrix(1, nrow = constants$nsites, ncol = nReducedYears)
)
newModel <- nimbleModel(occStateModel,
data = data,
constants = constants,
inits = inits,
check = FALSE)
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfType = "bootstrap",
pfControl = list(saveAll = TRUE,
#lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins)
)
devtools::load_all(".")
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfType = "bootstrap",
pfControl = list(saveAll = TRUE,
#lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins)
)
devtools::load_all(".")
spartaReducedFit <- spartaNimWeights(model = newModel, latent = "z",
pfType = "bootstrap",
pfControl = list(saveAll = TRUE,
#lookahead = "simulate",
smoothing = FALSE,
timeIndex = 2), #because z is a matrix
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins)
)
spartaReducedFit$logLike
spartaUpdatedFit <- spartaNimUpdates(model = newModel,
latent = "z",
pfType = "bootstrap",
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins),
weights = spartaReducedFit$weights,
unweightedLatentSamples = spartaReducedFit$unweightedSamples,
weightedLatentSamples = spartaReducedFit$weightedSamples,
loglike = spartaReducedFit$logLike,
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
)
spartaReducedFit$logLike
devtools::load_all(".")
spartaUpdatedFit <- spartaNimUpdates(model = newModel,
latent = "z",
pfType = "bootstrap",
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins),
weights = spartaReducedFit$weights,
unweightedLatentSamples = spartaReducedFit$unweightedSamples,
weightedLatentSamples = spartaReducedFit$weightedSamples,
loglike = spartaReducedFit$logLike,
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
)
devtools::load_all(".")
spartaUpdatedFit <- spartaNimUpdates(model = newModel,
latent = "z",
pfType = "bootstrap",
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins),
weights = spartaReducedFit$weights,
unweightedLatentSamples = spartaReducedFit$unweightedSamples,
weightedLatentSamples = spartaReducedFit$weightedSamples,
loglike = spartaReducedFit$logLike,
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
)
compiledParticleFilterEst
devtools::load_all(".")
spartaUpdatedFit <- spartaNimUpdates(model = newModel,
latent = "z",
pfType = "bootstrap",
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins),
weights = spartaReducedFit$weights,
unweightedLatentSamples = spartaReducedFit$unweightedSamples,
weightedLatentSamples = spartaReducedFit$weightedSamples,
loglike = spartaReducedFit$logLike,
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
)
devtools::load_all(".")
getwd()
setwd("/Volumes/kwakupa/particleFilters")
source("/Volumes/kwakupa/particleFilters/OccupancyStateSpaceModel.R")
devtools::load_all("~/Documents/GitHub/myphdthesis")
source("/Volumes/kwakupa/particleFilters/OccupancyStateSpaceModel.R")
model = newModel
latent = "z"
pfType = "bootstrap"
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins)
weights = spartaReducedFit$weights
unweightedLatentSamples = spartaReducedFit$unweightedSamples
weightedLatentSamples = spartaReducedFit$weightedSamples
loglike = spartaReducedFit$logLike
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
timeStart1 <- Sys.time()
target = MCMCconfiguration[["target"]]
additionalPars = MCMCconfiguration[["additionalPars"]] #other dependent variables you seek to monitor
n.iter = MCMCconfiguration[["n.iter"]]
n.chains = MCMCconfiguration[["n.chains"]]
n.burnin = MCMCconfiguration[["n.burnin"]]
iNodePrev = pfControl[["iNodePrev"]]
M = pfControl[["M"]]
#iNodePrev = updatePFControl[["iNodePrev"]]
#M = updatePFControl[["M"]]
if(is.null(nParFiltRun)) nParFiltRun = 10000
#create new model for weights
estimationModel <- model$newModel(replicate = TRUE)
nParFiltRun = 10000
#create new model for weights
estimationModel <- model$newModel(replicate = TRUE)
message("Building particle filter for model")
if(!is.null(pfType)){
if(!pfType %in% c("auxiliary", "bootstrap")) stop("Function currently works for auxiliary and bootstap Particle filters")
if(pfType == "bootstrap"){
particleFilter <- myphdthesis::buildBootstrapFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
particleFilterEst <- myphdthesis::buildBootstrapFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
}
}else{
particleFilter <- myphdthesis::buildAuxiliaryFilterUpdate(model,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
particleFilterEst <- myphdthesis::buildAuxiliaryFilterUpdate(estimationModel,
latent,
mvWSamplesWTSaved = weights,
mvWSamplesXSaved = unweightedLatentSamples,
mvEWSamplesXSaved = weightedLatentSamples,
logLikeVals = loglike,
control = pfControl)
}
message("Compiling the particle filter")
#compiling the model
compiledParticleFilter <- nimble::compileNimble(model,  particleFilter)
#Loflikelihood of last run and the Effective sample sizes
message("Running the particle filter")
logLik <-   compiledParticleFilter$particleFilter$run(m = nParFiltRun)
ESS <-   compiledParticleFilter$particleFilter$returnESS()
#save weights and samples
message("Extracting the weights and samples from particle fiter")
weightsNew <- as.matrix( compiledParticleFilter$particleFilter$mvWSamples, "wts")
unweightedSamples <- as.matrix( compiledParticleFilter$particleFilter$mvWSamples, latent)
weightedSamples <- as.matrix( compiledParticleFilter$particleFilter$mvEWSamples, latent)
if(pfType == "auxiliary"){
logLike <- as.matrix( compiledParticleFilter$particleFilterEst$mvWSamples, "auxlog")
}else{
logLike <- as.matrix( compiledParticleFilter$particleFilterEst$mvWSamples, "bootLL")
}
#newModel <- model$newModel(replicate = TRUE)
modelMCMCconf <- nimble::configureMCMC(model, nodes = NULL)
if(is.null(pfType)){
pfTypeUpdate = 'auxiliaryUpdate'
}else{
if(pfType == "bootstrap"){
pfTypeUpdate = 'bootstrapUpdate'
}else{
if(pfType == "auxiliary") {
pfTypeUpdate = 'auxiliaryUpdate'
}
mvWSamplesWTSaved = weights
mvWSamplesXSaved = unweightedLatentSamples
mvEWSamplesXSaved = weightedLatentSamples
modelMCMCconf$addSampler(target = target,
type = 'RW_PF_blockUpdate',
control = list(latents = latent,
pfControl = list(saveAll = TRUE, M = M, iNodePrev = iNodePrev),
pfNparticles = nParFiltRun,
pfType = pfTypeUpdate,
weights = weights,
unweightedSamples= unweightedLatentSamples,
weightedSamples = weightedLatentSamples,
logLikeVals = loglike))
modelMCMCconf$addMonitors(additionalPars)
message("Building and compiling the PF MCMC")
## build and compile pMCMC sampler
modelMCMC <- nimble::buildMCMC(modelMCMCconf)
compiledList <- nimble::compileNimble(model,
modelMCMC,
resetFunctions = TRUE)
timeStart2 <- Sys.time()
message("Running the PF MCMC")
#run MCMC
mcmc.out <- nimble::runMCMC(compiledList$modelMCMC,
niter = n.iter,
nchains = n.chains,
nburnin = n.burnin,
#inits = initsList,
#thin = 5,
setSeed = TRUE,
samples=TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
timeEnd <- Sys.time()
timetaken1 <- as.numeric(round(timeEnd - timeStart1, 2))
timetaken2 <- as.numeric(round(timeEnd - timeStart2, 2))
message(paste("Estimating weights at posteror values of ", target))
for(i in 1:length(target)){
estimationModel[[target[i]]] <- mcmc.out$summary$all.chains[target[i], 'Mean']
}
message("Compiling the estimation particle filter")
#compiling the model
compiledParticleFilterEst <- compileNimble(estimationModel,  particleFilterEst)
#Loglikelihood of last run and the Effective sample sizes
message("Running the estimation particle filter")
logLik <-   compiledParticleFilterEst$particleFilterEst$run(m = nParFiltRun)
ESS <-   compiledParticleFilterEst$particleFilterEst$returnESS()
#save weights and samples
message("Extracting the weights and samples from posterior particle fiter")
weights <- as.matrix(compiledParticleFilterEst$particleFilterEst$mvWSamples, "wts")
unweightedSamples <- as.matrix(compiledParticleFilterEst$particleFilterEst$mvWSamples, latent)
weightedSamples <- as.matrix( compiledParticleFilterEst$particleFilterEst$mvEWSamples, latent)
if(pfType == "auxiliary"){
logLike <- as.matrix(compiledParticleFilterEst$particleFilterEst$mvWSamples, "auxlog")
}else{
logLike <- as.matrix(compiledParticleFilterEst$particleFilterEst$mvWSamples, "bootLL")
}
message("Returning the results")
logLike
weightedSamples
unweightedSamples
weights
devtools::load_all("~/Documents/GitHub/myphdthesis")
spartaUpdatedFit <- spartaNimUpdates(model = newModel,
latent = "z",
pfType = "bootstrap",
MCMCconfiguration = list(target = targetsToMonitor,
additionalPars = c("psi.fs"),
n.iter = niters,
n.chains = nchains,
n.burnin = nburnins),
weights = spartaReducedFit$weights,
unweightedLatentSamples = spartaReducedFit$unweightedSamples,
weightedLatentSamples = spartaReducedFit$weightedSamples,
loglike = spartaReducedFit$logLike,
pfControl = list(saveAll = TRUE,
# lookahead = "simulate",
smoothing = FALSE,  M = 5,
iNodePrev = (nReducedYears),
timeIndex = 2)
)
devtools::load_all(".")
setwd("/Volumes/kwakupa/particleFilters")
load("/Volumes/kwakupa/particleFilters/reducedDynamicOccTRUE.RData")
spartaReducedFit$timeTakenAll
spartaReducedFit$timeTakenRun
spartaReducedFit$mcmcSamplesAndSummary$summary
load("/Volumes/kwakupa/particleFilters/dynamicOccNormalTRUE.RData")
